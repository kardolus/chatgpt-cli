// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/cohere-ai/cohere-go/v2/core"
	time "time"
)

type ChatRequest struct {
	// Text input for the model to respond to.
	Message string `json:"message" url:"message"`
	// Defaults to `command-r-plus`.
	//
	// The name of a compatible [Cohere model](https://docs.cohere.com/docs/models) or the ID of a [fine-tuned](https://docs.cohere.com/docs/chat-fine-tuning) model.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// When specified, the default Cohere preamble will be replaced with the provided one. Preambles are a part of the prompt used to adjust the model's overall behavior and conversation style, and use the `SYSTEM` role.
	//
	// The `SYSTEM` role is also used for the contents of the optional `chat_history=` parameter. When used with the `chat_history=` parameter it adds content throughout a conversation. Conversely, when used with the `preamble=` parameter it adds content at the start of the conversation only.
	Preamble *string `json:"preamble,omitempty" url:"preamble,omitempty"`
	// A list of previous messages between the user and the model, giving the model conversational context for responding to the user's `message`.
	//
	// Each item represents a single message in the chat history, excluding the current user turn. It has two properties: `role` and `message`. The `role` identifies the sender (`CHATBOT`, `SYSTEM`, or `USER`), while the `message` contains the text content.
	//
	// The chat_history parameter should not be used for `SYSTEM` messages in most cases. Instead, to add a `SYSTEM` role message at the beginning of a conversation, the `preamble` parameter should be used.
	ChatHistory []*ChatMessage `json:"chat_history,omitempty" url:"chat_history,omitempty"`
	// An alternative to `chat_history`.
	//
	// Providing a `conversation_id` creates or resumes a persisted conversation with the specified ID. The ID can be any non empty string.
	ConversationId *string `json:"conversation_id,omitempty" url:"conversation_id,omitempty"`
	// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
	//
	// Dictates how the prompt will be constructed.
	//
	// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be changed and ranked by relevance.
	//
	// With `prompt_truncation` set to "AUTO_PRESERVE_ORDER", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be preserved as they are inputted into the API.
	//
	// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
	PromptTruncation *ChatRequestPromptTruncation `json:"prompt_truncation,omitempty" url:"prompt_truncation,omitempty"`
	// Accepts `{"id": "web-search"}`, and/or the `"id"` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.
	//
	// When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).
	Connectors []*ChatConnector `json:"connectors,omitempty" url:"connectors,omitempty"`
	// Defaults to `false`.
	//
	// When `true`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's `message` will be generated.
	SearchQueriesOnly *bool `json:"search_queries_only,omitempty" url:"search_queries_only,omitempty"`
	// A list of relevant documents that the model can cite to generate a more accurate reply. Each document is a string-string dictionary.
	//
	// Example:
	// `[
	//
	//	{ "title": "Tall penguins", "text": "Emperor penguins are the tallest." },
	//	{ "title": "Penguin habitats", "text": "Emperor penguins only live in Antarctica." },
	//
	// ]`
	//
	// Keys and values from each document will be serialized to a string and passed to the model. The resulting generation will include citations that reference some of these documents.
	//
	// Some suggested keys are "text", "author", and "date". For better generation quality, it is recommended to keep the total word count of the strings in the dictionary to under 300 words.
	//
	// An `id` field (string) can be optionally supplied to identify the document in the citations. This field will not be passed to the model.
	//
	// An `_excludes` field (array of strings) can be optionally supplied to omit some key-value pairs from being shown to the model. The omitted fields will still show up in the citation object. The "_excludes" field will not be passed to the model.
	//
	// See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.
	Documents []ChatDocument `json:"documents,omitempty" url:"documents,omitempty"`
	// Defaults to `"accurate"`.
	//
	// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
	CitationQuality *ChatRequestCitationQuality `json:"citation_quality,omitempty" url:"citation_quality,omitempty"`
	// Defaults to `0.3`.
	//
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.
	//
	// Randomness can be further maximized by increasing the  value of the `p` parameter.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	MaxTokens *int `json:"max_tokens,omitempty" url:"max_tokens,omitempty"`
	// The maximum number of input tokens to send to the model. If not specified, `max_input_tokens` is the model's context length limit minus a small buffer.
	//
	// Input will be truncated according to the `prompt_truncation` parameter.
	MaxInputTokens *int `json:"max_input_tokens,omitempty" url:"max_input_tokens,omitempty"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty" url:"k,omitempty"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty" url:"p,omitempty"`
	// If specified, the backend will make a best effort to sample tokens deterministically, such that repeated requests with the same seed and parameters should return the same result. However, determinism cannot be totally guaranteed.
	Seed *float64 `json:"seed,omitempty" url:"seed,omitempty"`
	// A list of up to 5 strings that the model will use to stop generation. If the model generates a string that matches any of the strings in the list, it will stop generating tokens and return the generated text up to that point not including the stop sequence.
	StopSequences []string `json:"stop_sequences,omitempty" url:"stop_sequences,omitempty"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"frequency_penalty,omitempty"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"presence_penalty,omitempty"`
	// When enabled, the user's prompt will be sent to the model without any pre-processing.
	RawPrompting *bool `json:"raw_prompting,omitempty" url:"raw_prompting,omitempty"`
	// The prompt is returned in the `prompt` response field when this is enabled.
	ReturnPrompt *bool `json:"return_prompt,omitempty" url:"return_prompt,omitempty"`
	// A list of available tools (functions) that the model may suggest invoking before producing a text response.
	//
	// When `tools` is passed (without `tool_results`), the `text` field in the response will be `""` and the `tool_calls` field in the response will be populated with a list of tool calls that need to be made. If no calls need to be made, the `tool_calls` array will be empty.
	Tools []*Tool `json:"tools,omitempty" url:"tools,omitempty"`
	// A list of results from invoking tools recommended by the model in the previous chat turn. Results are used to produce a text response and will be referenced in citations. When using `tool_results`, `tools` must be passed as well.
	// Each tool_result contains information about how it was invoked, as well as a list of outputs in the form of dictionaries.
	//
	// **Note**: `outputs` must be a list of objects. If your tool returns a single object (eg `{"status": 200}`), make sure to wrap it in a list.
	// ```
	// tool_results = [
	//
	//	{
	//	  "call": {
	//	    "name": <tool name>,
	//	    "parameters": {
	//	      <param name>: <param value>
	//	    }
	//	  },
	//	  "outputs": [{
	//	    <key>: <value>
	//	  }]
	//	},
	//	...
	//
	// ]
	// ```
	// **Note**: Chat calls with `tool_results` should not be included in the Chat history to avoid duplication of the message text.
	ToolResults []*ChatRequestToolResultsItem `json:"tool_results,omitempty" url:"tool_results,omitempty"`
	stream      bool
}

func (c *ChatRequest) Stream() bool {
	return c.stream
}

func (c *ChatRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*c = ChatRequest(body)
	c.stream = false
	return nil
}

func (c *ChatRequest) MarshalJSON() ([]byte, error) {
	type embed ChatRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*c),
		Stream: false,
	}
	return json.Marshal(marshaler)
}

type ChatStreamRequest struct {
	// Text input for the model to respond to.
	Message string `json:"message" url:"message"`
	// Defaults to `command-r-plus`.
	//
	// The name of a compatible [Cohere model](https://docs.cohere.com/docs/models) or the ID of a [fine-tuned](https://docs.cohere.com/docs/chat-fine-tuning) model.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// When specified, the default Cohere preamble will be replaced with the provided one. Preambles are a part of the prompt used to adjust the model's overall behavior and conversation style, and use the `SYSTEM` role.
	//
	// The `SYSTEM` role is also used for the contents of the optional `chat_history=` parameter. When used with the `chat_history=` parameter it adds content throughout a conversation. Conversely, when used with the `preamble=` parameter it adds content at the start of the conversation only.
	Preamble *string `json:"preamble,omitempty" url:"preamble,omitempty"`
	// A list of previous messages between the user and the model, giving the model conversational context for responding to the user's `message`.
	//
	// Each item represents a single message in the chat history, excluding the current user turn. It has two properties: `role` and `message`. The `role` identifies the sender (`CHATBOT`, `SYSTEM`, or `USER`), while the `message` contains the text content.
	//
	// The chat_history parameter should not be used for `SYSTEM` messages in most cases. Instead, to add a `SYSTEM` role message at the beginning of a conversation, the `preamble` parameter should be used.
	ChatHistory []*ChatMessage `json:"chat_history,omitempty" url:"chat_history,omitempty"`
	// An alternative to `chat_history`.
	//
	// Providing a `conversation_id` creates or resumes a persisted conversation with the specified ID. The ID can be any non empty string.
	ConversationId *string `json:"conversation_id,omitempty" url:"conversation_id,omitempty"`
	// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
	//
	// Dictates how the prompt will be constructed.
	//
	// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be changed and ranked by relevance.
	//
	// With `prompt_truncation` set to "AUTO_PRESERVE_ORDER", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be preserved as they are inputted into the API.
	//
	// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
	PromptTruncation *ChatStreamRequestPromptTruncation `json:"prompt_truncation,omitempty" url:"prompt_truncation,omitempty"`
	// Accepts `{"id": "web-search"}`, and/or the `"id"` for a custom [connector](https://docs.cohere.com/docs/connectors), if you've [created](https://docs.cohere.com/docs/creating-and-deploying-a-connector) one.
	//
	// When specified, the model's reply will be enriched with information found by quering each of the connectors (RAG).
	Connectors []*ChatConnector `json:"connectors,omitempty" url:"connectors,omitempty"`
	// Defaults to `false`.
	//
	// When `true`, the response will only contain a list of generated search queries, but no search will take place, and no reply from the model to the user's `message` will be generated.
	SearchQueriesOnly *bool `json:"search_queries_only,omitempty" url:"search_queries_only,omitempty"`
	// A list of relevant documents that the model can cite to generate a more accurate reply. Each document is a string-string dictionary.
	//
	// Example:
	// `[
	//
	//	{ "title": "Tall penguins", "text": "Emperor penguins are the tallest." },
	//	{ "title": "Penguin habitats", "text": "Emperor penguins only live in Antarctica." },
	//
	// ]`
	//
	// Keys and values from each document will be serialized to a string and passed to the model. The resulting generation will include citations that reference some of these documents.
	//
	// Some suggested keys are "text", "author", and "date". For better generation quality, it is recommended to keep the total word count of the strings in the dictionary to under 300 words.
	//
	// An `id` field (string) can be optionally supplied to identify the document in the citations. This field will not be passed to the model.
	//
	// An `_excludes` field (array of strings) can be optionally supplied to omit some key-value pairs from being shown to the model. The omitted fields will still show up in the citation object. The "_excludes" field will not be passed to the model.
	//
	// See ['Document Mode'](https://docs.cohere.com/docs/retrieval-augmented-generation-rag#document-mode) in the guide for more information.
	Documents []ChatDocument `json:"documents,omitempty" url:"documents,omitempty"`
	// Defaults to `"accurate"`.
	//
	// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
	CitationQuality *ChatStreamRequestCitationQuality `json:"citation_quality,omitempty" url:"citation_quality,omitempty"`
	// Defaults to `0.3`.
	//
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations, and higher temperatures mean more random generations.
	//
	// Randomness can be further maximized by increasing the  value of the `p` parameter.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	MaxTokens *int `json:"max_tokens,omitempty" url:"max_tokens,omitempty"`
	// The maximum number of input tokens to send to the model. If not specified, `max_input_tokens` is the model's context length limit minus a small buffer.
	//
	// Input will be truncated according to the `prompt_truncation` parameter.
	MaxInputTokens *int `json:"max_input_tokens,omitempty" url:"max_input_tokens,omitempty"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty" url:"k,omitempty"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty" url:"p,omitempty"`
	// If specified, the backend will make a best effort to sample tokens deterministically, such that repeated requests with the same seed and parameters should return the same result. However, determinism cannot be totally guaranteed.
	Seed *float64 `json:"seed,omitempty" url:"seed,omitempty"`
	// A list of up to 5 strings that the model will use to stop generation. If the model generates a string that matches any of the strings in the list, it will stop generating tokens and return the generated text up to that point not including the stop sequence.
	StopSequences []string `json:"stop_sequences,omitempty" url:"stop_sequences,omitempty"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"frequency_penalty,omitempty"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"presence_penalty,omitempty"`
	// When enabled, the user's prompt will be sent to the model without any pre-processing.
	RawPrompting *bool `json:"raw_prompting,omitempty" url:"raw_prompting,omitempty"`
	// The prompt is returned in the `prompt` response field when this is enabled.
	ReturnPrompt *bool `json:"return_prompt,omitempty" url:"return_prompt,omitempty"`
	// A list of available tools (functions) that the model may suggest invoking before producing a text response.
	//
	// When `tools` is passed (without `tool_results`), the `text` field in the response will be `""` and the `tool_calls` field in the response will be populated with a list of tool calls that need to be made. If no calls need to be made, the `tool_calls` array will be empty.
	Tools []*Tool `json:"tools,omitempty" url:"tools,omitempty"`
	// A list of results from invoking tools recommended by the model in the previous chat turn. Results are used to produce a text response and will be referenced in citations. When using `tool_results`, `tools` must be passed as well.
	// Each tool_result contains information about how it was invoked, as well as a list of outputs in the form of dictionaries.
	//
	// **Note**: `outputs` must be a list of objects. If your tool returns a single object (eg `{"status": 200}`), make sure to wrap it in a list.
	// ```
	// tool_results = [
	//
	//	{
	//	  "call": {
	//	    "name": <tool name>,
	//	    "parameters": {
	//	      <param name>: <param value>
	//	    }
	//	  },
	//	  "outputs": [{
	//	    <key>: <value>
	//	  }]
	//	},
	//	...
	//
	// ]
	// ```
	// **Note**: Chat calls with `tool_results` should not be included in the Chat history to avoid duplication of the message text.
	ToolResults []*ChatStreamRequestToolResultsItem `json:"tool_results,omitempty" url:"tool_results,omitempty"`
	stream      bool
}

func (c *ChatStreamRequest) Stream() bool {
	return c.stream
}

func (c *ChatStreamRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*c = ChatStreamRequest(body)
	c.stream = true
	return nil
}

func (c *ChatStreamRequest) MarshalJSON() ([]byte, error) {
	type embed ChatStreamRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*c),
		Stream: true,
	}
	return json.Marshal(marshaler)
}

type ClassifyRequest struct {
	// A list of up to 96 texts to be classified. Each one must be a non-empty string.
	// There is, however, no consistent, universal limit to the length a particular input can be. We perform classification on the first `x` tokens of each input, and `x` varies depending on which underlying model is powering classification. The maximum token length for each model is listed in the "max tokens" column [here](https://docs.cohere.com/docs/models).
	// Note: by default the `truncate` parameter is set to `END`, so tokens exceeding the limit will be automatically dropped. This behavior can be disabled by setting `truncate` to `NONE`, which will result in validation errors for longer texts.
	Inputs []string `json:"inputs,omitempty" url:"inputs,omitempty"`
	// An array of examples to provide context to the model. Each example is a text string and its associated label/class. Each unique label requires at least 2 examples associated with it; the maximum number of examples is 2500, and each example has a maximum length of 512 tokens. The values should be structured as `{text: "...",label: "..."}`.
	// Note: [Fine-tuned Models](https://docs.cohere.com/docs/classify-fine-tuning) trained on classification examples don't require the `examples` parameter to be passed in explicitly.
	Examples []*ClassifyExample `json:"examples,omitempty" url:"examples,omitempty"`
	// The identifier of the model. Currently available models are `embed-multilingual-v2.0`, `embed-english-light-v2.0`, and `embed-english-v2.0` (default). Smaller "light" models are faster, while larger models will perform better. [Fine-tuned models](https://docs.cohere.com/docs/fine-tuning) can also be supplied with their full ID.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// The ID of a custom playground preset. You can create presets in the [playground](https://dashboard.cohere.ai/playground/classify?model=large). If you use a preset, all other parameters become optional, and any included parameters will override the preset's parameters.
	Preset *string `json:"preset,omitempty" url:"preset,omitempty"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *ClassifyRequestTruncate `json:"truncate,omitempty" url:"truncate,omitempty"`
}

type DetokenizeRequest struct {
	// The list of tokens to be detokenized.
	Tokens []int `json:"tokens,omitempty" url:"tokens,omitempty"`
	// An optional parameter to provide the model name. This will ensure that the detokenization is done by the tokenizer used by that model.
	Model string `json:"model" url:"model"`
}

type EmbedRequest struct {
	// An array of strings for the model to embed. Maximum number of texts per call is `96`. We recommend reducing the length of each text to be under `512` tokens for optimal quality.
	Texts []string `json:"texts,omitempty" url:"texts,omitempty"`
	// Defaults to embed-english-v2.0
	//
	// The identifier of the model. Smaller "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
	//
	// Available models and corresponding embedding dimensions:
	//
	// * `embed-english-v3.0`  1024
	// * `embed-multilingual-v3.0`  1024
	// * `embed-english-light-v3.0`  384
	// * `embed-multilingual-light-v3.0`  384
	//
	// * `embed-english-v2.0`  4096
	// * `embed-english-light-v2.0`  1024
	// * `embed-multilingual-v2.0`  768
	Model     *string         `json:"model,omitempty" url:"model,omitempty"`
	InputType *EmbedInputType `json:"input_type,omitempty" url:"input_type,omitempty"`
	// Specifies the types of embeddings you want to get back. Not required and default is None, which returns the Embed Floats response type. Can be one or more of the following types.
	//
	// * `"float"`: Use this when you want to get back the default float embeddings. Valid for all models.
	// * `"int8"`: Use this when you want to get back signed int8 embeddings. Valid for only v3 models.
	// * `"uint8"`: Use this when you want to get back unsigned int8 embeddings. Valid for only v3 models.
	// * `"binary"`: Use this when you want to get back signed binary embeddings. Valid for only v3 models.
	// * `"ubinary"`: Use this when you want to get back unsigned binary embeddings. Valid for only v3 models.
	EmbeddingTypes []EmbeddingType `json:"embedding_types,omitempty" url:"embedding_types,omitempty"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *EmbedRequestTruncate `json:"truncate,omitempty" url:"truncate,omitempty"`
}

type GenerateRequest struct {
	// The input text that serves as the starting point for generating the response.
	// Note: The prompt will be pre-processed and modified before reaching the model.
	Prompt string `json:"prompt" url:"prompt"`
	// The identifier of the model to generate with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental).
	// Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// The maximum number of generations that will be returned. Defaults to `1`, min value of `1`, max value of `5`.
	NumGenerations *int `json:"num_generations,omitempty" url:"num_generations,omitempty"`
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	//
	// This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.
	//
	// Can only be set to `0` if `return_likelihoods` is set to `ALL` to get the likelihood of the prompt.
	MaxTokens *int `json:"max_tokens,omitempty" url:"max_tokens,omitempty"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *GenerateRequestTruncate `json:"truncate,omitempty" url:"truncate,omitempty"`
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
	// Defaults to `0.75`, min value of `0.0`, max value of `5.0`.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// If specified, the backend will make a best effort to sample tokens deterministically, such that repeated requests with the same seed and parameters should return the same result. However, determinsim cannot be totally guaranteed.
	Seed *float64 `json:"seed,omitempty" url:"seed,omitempty"`
	// Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.ai/playground/generate).
	// When a preset is specified, the `prompt` parameter becomes optional, and any included parameters will override the preset's parameters.
	Preset *string `json:"preset,omitempty" url:"preset,omitempty"`
	// The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.
	EndSequences []string `json:"end_sequences,omitempty" url:"end_sequences,omitempty"`
	// The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.
	StopSequences []string `json:"stop_sequences,omitempty" url:"stop_sequences,omitempty"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty" url:"k,omitempty"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty" url:"p,omitempty"`
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"frequency_penalty,omitempty"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"presence_penalty,omitempty"`
	// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
	//
	// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
	//
	// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
	ReturnLikelihoods *GenerateRequestReturnLikelihoods `json:"return_likelihoods,omitempty" url:"return_likelihoods,omitempty"`
	// When enabled, the user's prompt will be sent to the model without any pre-processing.
	RawPrompting *bool `json:"raw_prompting,omitempty" url:"raw_prompting,omitempty"`
	stream       bool
}

func (g *GenerateRequest) Stream() bool {
	return g.stream
}

func (g *GenerateRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*g = GenerateRequest(body)
	g.stream = false
	return nil
}

func (g *GenerateRequest) MarshalJSON() ([]byte, error) {
	type embed GenerateRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*g),
		Stream: false,
	}
	return json.Marshal(marshaler)
}

type GenerateStreamRequest struct {
	// The input text that serves as the starting point for generating the response.
	// Note: The prompt will be pre-processed and modified before reaching the model.
	Prompt string `json:"prompt" url:"prompt"`
	// The identifier of the model to generate with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental).
	// Smaller, "light" models are faster, while larger models will perform better. [Custom models](/docs/training-custom-models) can also be supplied with their full ID.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// The maximum number of generations that will be returned. Defaults to `1`, min value of `1`, max value of `5`.
	NumGenerations *int `json:"num_generations,omitempty" url:"num_generations,omitempty"`
	// The maximum number of tokens the model will generate as part of the response. Note: Setting a low value may result in incomplete generations.
	//
	// This parameter is off by default, and if it's not specified, the model will continue generating until it emits an EOS completion token. See [BPE Tokens](/bpe-tokens-wiki) for more details.
	//
	// Can only be set to `0` if `return_likelihoods` is set to `ALL` to get the likelihood of the prompt.
	MaxTokens *int `json:"max_tokens,omitempty" url:"max_tokens,omitempty"`
	// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
	//
	// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
	//
	// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
	Truncate *GenerateStreamRequestTruncate `json:"truncate,omitempty" url:"truncate,omitempty"`
	// A non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations. See [Temperature](/temperature-wiki) for more details.
	// Defaults to `0.75`, min value of `0.0`, max value of `5.0`.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// If specified, the backend will make a best effort to sample tokens deterministically, such that repeated requests with the same seed and parameters should return the same result. However, determinsim cannot be totally guaranteed.
	Seed *float64 `json:"seed,omitempty" url:"seed,omitempty"`
	// Identifier of a custom preset. A preset is a combination of parameters, such as prompt, temperature etc. You can create presets in the [playground](https://dashboard.cohere.ai/playground/generate).
	// When a preset is specified, the `prompt` parameter becomes optional, and any included parameters will override the preset's parameters.
	Preset *string `json:"preset,omitempty" url:"preset,omitempty"`
	// The generated text will be cut at the beginning of the earliest occurrence of an end sequence. The sequence will be excluded from the text.
	EndSequences []string `json:"end_sequences,omitempty" url:"end_sequences,omitempty"`
	// The generated text will be cut at the end of the earliest occurrence of a stop sequence. The sequence will be included the text.
	StopSequences []string `json:"stop_sequences,omitempty" url:"stop_sequences,omitempty"`
	// Ensures only the top `k` most likely tokens are considered for generation at each step.
	// Defaults to `0`, min value of `0`, max value of `500`.
	K *int `json:"k,omitempty" url:"k,omitempty"`
	// Ensures that only the most likely tokens, with total probability mass of `p`, are considered for generation at each step. If both `k` and `p` are enabled, `p` acts after `k`.
	// Defaults to `0.75`. min value of `0.01`, max value of `0.99`.
	P *float64 `json:"p,omitempty" url:"p,omitempty"`
	// Used to reduce repetitiveness of generated tokens. The higher the value, the stronger a penalty is applied to previously present tokens, proportional to how many times they have already appeared in the prompt or prior generation.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	FrequencyPenalty *float64 `json:"frequency_penalty,omitempty" url:"frequency_penalty,omitempty"`
	// Defaults to `0.0`, min value of `0.0`, max value of `1.0`.
	//
	// Can be used to reduce repetitiveness of generated tokens. Similar to `frequency_penalty`, except that this penalty is applied equally to all tokens that have already appeared, regardless of their exact frequencies.
	//
	// Using `frequency_penalty` in combination with `presence_penalty` is not supported on newer models.
	PresencePenalty *float64 `json:"presence_penalty,omitempty" url:"presence_penalty,omitempty"`
	// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
	//
	// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
	//
	// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
	ReturnLikelihoods *GenerateStreamRequestReturnLikelihoods `json:"return_likelihoods,omitempty" url:"return_likelihoods,omitempty"`
	// When enabled, the user's prompt will be sent to the model without any pre-processing.
	RawPrompting *bool `json:"raw_prompting,omitempty" url:"raw_prompting,omitempty"`
	stream       bool
}

func (g *GenerateStreamRequest) Stream() bool {
	return g.stream
}

func (g *GenerateStreamRequest) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamRequest
	var body unmarshaler
	if err := json.Unmarshal(data, &body); err != nil {
		return err
	}
	*g = GenerateStreamRequest(body)
	g.stream = true
	return nil
}

func (g *GenerateStreamRequest) MarshalJSON() ([]byte, error) {
	type embed GenerateStreamRequest
	var marshaler = struct {
		embed
		Stream bool `json:"stream"`
	}{
		embed:  embed(*g),
		Stream: true,
	}
	return json.Marshal(marshaler)
}

type RerankRequest struct {
	// The identifier of the model to use, one of : `rerank-english-v3.0`, `rerank-multilingual-v3.0`, `rerank-english-v2.0`, `rerank-multilingual-v2.0`
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// The search query
	Query string `json:"query" url:"query"`
	// A list of document objects or strings to rerank.
	// If a document is provided the text fields is required and all other fields will be preserved in the response.
	//
	// The total max chunks (length of documents * max_chunks_per_doc) must be less than 10000.
	//
	// We recommend a maximum of 1,000 documents for optimal endpoint performance.
	Documents []*RerankRequestDocumentsItem `json:"documents,omitempty" url:"documents,omitempty"`
	// The number of most relevant documents or indices to return, defaults to the length of the documents
	TopN *int `json:"top_n,omitempty" url:"top_n,omitempty"`
	// If a JSON object is provided, you can specify which keys you would like to have considered for reranking. The model will rerank based on order of the fields passed in (i.e. rank_fields=['title','author','text'] will rerank using the values in title, author, text  sequentially. If the length of title, author, and text exceeds the context length of the model, the chunking will not re-consider earlier fields). If not provided, the model will use the default text field for ranking.
	RankFields []string `json:"rank_fields,omitempty" url:"rank_fields,omitempty"`
	// - If false, returns results without the doc text - the api will return a list of {index, relevance score} where index is inferred from the list passed into the request.
	// - If true, returns results with the doc text passed in - the api will return an ordered list of {index, text, relevance score} where index + text refers to the list passed into the request.
	ReturnDocuments *bool `json:"return_documents,omitempty" url:"return_documents,omitempty"`
	// The maximum number of chunks to produce internally from a document
	MaxChunksPerDoc *int `json:"max_chunks_per_doc,omitempty" url:"max_chunks_per_doc,omitempty"`
}

type SummarizeRequest struct {
	// The text to generate a summary for. Can be up to 100,000 characters long. Currently the only supported language is English.
	Text string `json:"text" url:"text"`
	// One of `short`, `medium`, `long`, or `auto` defaults to `auto`. Indicates the approximate length of the summary. If `auto` is selected, the best option will be picked based on the input text.
	Length *SummarizeRequestLength `json:"length,omitempty" url:"length,omitempty"`
	// One of `paragraph`, `bullets`, or `auto`, defaults to `auto`. Indicates the style in which the summary will be delivered - in a free form paragraph or in bullet points. If `auto` is selected, the best option will be picked based on the input text.
	Format *SummarizeRequestFormat `json:"format,omitempty" url:"format,omitempty"`
	// The identifier of the model to generate the summary with. Currently available models are `command` (default), `command-nightly` (experimental), `command-light`, and `command-light-nightly` (experimental). Smaller, "light" models are faster, while larger models will perform better.
	Model *string `json:"model,omitempty" url:"model,omitempty"`
	// One of `low`, `medium`, `high`, or `auto`, defaults to `auto`. Controls how close to the original text the summary is. `high` extractiveness summaries will lean towards reusing sentences verbatim, while `low` extractiveness summaries will tend to paraphrase more. If `auto` is selected, the best option will be picked based on the input text.
	Extractiveness *SummarizeRequestExtractiveness `json:"extractiveness,omitempty" url:"extractiveness,omitempty"`
	// Ranges from 0 to 5. Controls the randomness of the output. Lower values tend to generate more “predictable” output, while higher values tend to generate more “creative” output. The sweet spot is typically between 0 and 1.
	Temperature *float64 `json:"temperature,omitempty" url:"temperature,omitempty"`
	// A free-form instruction for modifying how the summaries get generated. Should complete the sentence "Generate a summary _". Eg. "focusing on the next steps" or "written by Yoda"
	AdditionalCommand *string `json:"additional_command,omitempty" url:"additional_command,omitempty"`
}

type TokenizeRequest struct {
	// The string to be tokenized, the minimum text length is 1 character, and the maximum text length is 65536 characters.
	Text string `json:"text" url:"text"`
	// An optional parameter to provide the model name. This will ensure that the tokenization uses the tokenizer used by that model.
	Model string `json:"model" url:"model"`
}

type ApiMeta struct {
	ApiVersion  *ApiMetaApiVersion  `json:"api_version,omitempty" url:"api_version,omitempty"`
	BilledUnits *ApiMetaBilledUnits `json:"billed_units,omitempty" url:"billed_units,omitempty"`
	Tokens      *ApiMetaTokens      `json:"tokens,omitempty" url:"tokens,omitempty"`
	Warnings    []string            `json:"warnings,omitempty" url:"warnings,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApiMeta) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMeta
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMeta(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMeta) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiMetaApiVersion struct {
	Version        string `json:"version" url:"version"`
	IsDeprecated   *bool  `json:"is_deprecated,omitempty" url:"is_deprecated,omitempty"`
	IsExperimental *bool  `json:"is_experimental,omitempty" url:"is_experimental,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApiMetaApiVersion) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMetaApiVersion
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMetaApiVersion(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMetaApiVersion) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiMetaBilledUnits struct {
	// The number of billed input tokens.
	InputTokens *float64 `json:"input_tokens,omitempty" url:"input_tokens,omitempty"`
	// The number of billed output tokens.
	OutputTokens *float64 `json:"output_tokens,omitempty" url:"output_tokens,omitempty"`
	// The number of billed search units.
	SearchUnits *float64 `json:"search_units,omitempty" url:"search_units,omitempty"`
	// The number of billed classifications units.
	Classifications *float64 `json:"classifications,omitempty" url:"classifications,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApiMetaBilledUnits) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMetaBilledUnits
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMetaBilledUnits(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMetaBilledUnits) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

type ApiMetaTokens struct {
	// The number of tokens used as input to the model.
	InputTokens *float64 `json:"input_tokens,omitempty" url:"input_tokens,omitempty"`
	// The number of tokens produced by the model.
	OutputTokens *float64 `json:"output_tokens,omitempty" url:"output_tokens,omitempty"`

	_rawJSON json.RawMessage
}

func (a *ApiMetaTokens) UnmarshalJSON(data []byte) error {
	type unmarshaler ApiMetaTokens
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*a = ApiMetaTokens(value)
	a._rawJSON = json.RawMessage(data)
	return nil
}

func (a *ApiMetaTokens) String() string {
	if len(a._rawJSON) > 0 {
		if value, err := core.StringifyJSON(a._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(a); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", a)
}

// The token_type specifies the way the token is passed in the Authorization header. Valid values are "bearer", "basic", and "noscheme".
type AuthTokenType string

const (
	AuthTokenTypeBearer   AuthTokenType = "bearer"
	AuthTokenTypeBasic    AuthTokenType = "basic"
	AuthTokenTypeNoscheme AuthTokenType = "noscheme"
)

func NewAuthTokenTypeFromString(s string) (AuthTokenType, error) {
	switch s {
	case "bearer":
		return AuthTokenTypeBearer, nil
	case "basic":
		return AuthTokenTypeBasic, nil
	case "noscheme":
		return AuthTokenTypeNoscheme, nil
	}
	var t AuthTokenType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AuthTokenType) Ptr() *AuthTokenType {
	return &a
}

// A section of the generated reply which cites external knowledge.
type ChatCitation struct {
	// The index of text that the citation starts at, counting from zero. For example, a generation of `Hello, world!` with a citation on `world` would have a start value of `7`. This is because the citation starts at `w`, which is the seventh character.
	Start int `json:"start" url:"start"`
	// The index of text that the citation ends after, counting from zero. For example, a generation of `Hello, world!` with a citation on `world` would have an end value of `11`. This is because the citation ends after `d`, which is the eleventh character.
	End int `json:"end" url:"end"`
	// The text of the citation. For example, a generation of `Hello, world!` with a citation of `world` would have a text value of `world`.
	Text string `json:"text" url:"text"`
	// Identifiers of documents cited by this section of the generated reply.
	DocumentIds []string `json:"document_ids,omitempty" url:"document_ids,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatCitation) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatCitation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatCitation(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCitation) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatCitationGenerationEvent struct {
	// Citations for the generated reply.
	Citations []*ChatCitation `json:"citations,omitempty" url:"citations,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatCitationGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatCitationGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatCitationGenerationEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatCitationGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The connector used for fetching documents.
type ChatConnector struct {
	// The identifier of the connector.
	Id string `json:"id" url:"id"`
	// When specified, this user access token will be passed to the connector in the Authorization header instead of the Cohere generated one.
	UserAccessToken *string `json:"user_access_token,omitempty" url:"user_access_token,omitempty"`
	// Defaults to `false`.
	//
	// When `true`, the request will continue if this connector returned an error.
	ContinueOnFailure *bool `json:"continue_on_failure,omitempty" url:"continue_on_failure,omitempty"`
	// Provides the connector with different settings at request time. The key/value pairs of this object are specific to each connector.
	//
	// For example, the connector `web-search` supports the `site` option, which limits search results to the specified domain.
	Options map[string]interface{} `json:"options,omitempty" url:"options,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatConnector) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatConnector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatConnector(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatConnector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatDataMetrics struct {
	// The sum of all turns of valid train examples.
	NumTrainTurns *string `json:"num_train_turns,omitempty" url:"num_train_turns,omitempty"`
	// The sum of all turns of valid eval examples.
	NumEvalTurns *string `json:"num_eval_turns,omitempty" url:"num_eval_turns,omitempty"`
	// The preamble of this dataset.
	Preamble *string `json:"preamble,omitempty" url:"preamble,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatDataMetrics) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatDataMetrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatDataMetrics(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatDataMetrics) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Relevant information that could be used by the model to generate a more accurate reply.
// The contents of each document are generally short (under 300 words), and are passed in the form of a
// dictionary of strings. Some suggested keys are "text", "author", "date". Both the key name and the value will be
// passed to the model.
type ChatDocument = map[string]string

// Represents a single message in the chat history, excluding the current user turn. It has two properties: `role` and `message`. The `role` identifies the sender (`CHATBOT`, `SYSTEM`, or `USER`), while the `message` contains the text content.
//
// The chat_history parameter should not be used for `SYSTEM` messages in most cases. Instead, to add a `SYSTEM` role message at the beginning of a conversation, the `preamble` parameter should be used.
type ChatMessage struct {
	// One of `CHATBOT`, `SYSTEM`, or `USER` to identify who the message is coming from.
	Role ChatMessageRole `json:"role" url:"role"`
	// Contents of the chat message.
	Message string `json:"message" url:"message"`

	_rawJSON json.RawMessage
}

func (c *ChatMessage) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatMessage
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatMessage(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatMessage) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// One of `CHATBOT`, `SYSTEM`, or `USER` to identify who the message is coming from.
type ChatMessageRole string

const (
	ChatMessageRoleChatbot ChatMessageRole = "CHATBOT"
	ChatMessageRoleSystem  ChatMessageRole = "SYSTEM"
	ChatMessageRoleUser    ChatMessageRole = "USER"
)

func NewChatMessageRoleFromString(s string) (ChatMessageRole, error) {
	switch s {
	case "CHATBOT":
		return ChatMessageRoleChatbot, nil
	case "SYSTEM":
		return ChatMessageRoleSystem, nil
	case "USER":
		return ChatMessageRoleUser, nil
	}
	var t ChatMessageRole
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatMessageRole) Ptr() *ChatMessageRole {
	return &c
}

// Defaults to `"accurate"`.
//
// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
type ChatRequestCitationQuality string

const (
	ChatRequestCitationQualityFast     ChatRequestCitationQuality = "fast"
	ChatRequestCitationQualityAccurate ChatRequestCitationQuality = "accurate"
)

func NewChatRequestCitationQualityFromString(s string) (ChatRequestCitationQuality, error) {
	switch s {
	case "fast":
		return ChatRequestCitationQualityFast, nil
	case "accurate":
		return ChatRequestCitationQualityAccurate, nil
	}
	var t ChatRequestCitationQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatRequestCitationQuality) Ptr() *ChatRequestCitationQuality {
	return &c
}

// (internal) Sets inference and model options for RAG search query and tool use generations. Defaults are used when options are not specified here, meaning that other parameters outside of connectors_search_options are ignored (such as model= or temperature=).
type ChatRequestConnectorsSearchOptions struct {
	Model       interface{} `json:"model,omitempty" url:"model,omitempty"`
	Temperature interface{} `json:"temperature,omitempty" url:"temperature,omitempty"`
	MaxTokens   interface{} `json:"max_tokens,omitempty" url:"max_tokens,omitempty"`
	Preamble    interface{} `json:"preamble,omitempty" url:"preamble,omitempty"`
	// If specified, the backend will make a best effort to sample tokens deterministically, such that repeated requests with the same seed and parameters should return the same result. However, determinsim cannot be totally guaranteed.
	Seed *float64 `json:"seed,omitempty" url:"seed,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatRequestConnectorsSearchOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatRequestConnectorsSearchOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatRequestConnectorsSearchOptions(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatRequestConnectorsSearchOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
//
// Dictates how the prompt will be constructed.
//
// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be changed and ranked by relevance.
//
// With `prompt_truncation` set to "AUTO_PRESERVE_ORDER", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be preserved as they are inputted into the API.
//
// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
type ChatRequestPromptTruncation string

const (
	ChatRequestPromptTruncationOff               ChatRequestPromptTruncation = "OFF"
	ChatRequestPromptTruncationAuto              ChatRequestPromptTruncation = "AUTO"
	ChatRequestPromptTruncationAutoPreserveOrder ChatRequestPromptTruncation = "AUTO_PRESERVE_ORDER"
)

func NewChatRequestPromptTruncationFromString(s string) (ChatRequestPromptTruncation, error) {
	switch s {
	case "OFF":
		return ChatRequestPromptTruncationOff, nil
	case "AUTO":
		return ChatRequestPromptTruncationAuto, nil
	case "AUTO_PRESERVE_ORDER":
		return ChatRequestPromptTruncationAutoPreserveOrder, nil
	}
	var t ChatRequestPromptTruncation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatRequestPromptTruncation) Ptr() *ChatRequestPromptTruncation {
	return &c
}

type ChatRequestToolResultsItem struct {
	Call    *ToolCall                `json:"call,omitempty" url:"call,omitempty"`
	Outputs []map[string]interface{} `json:"outputs,omitempty" url:"outputs,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatRequestToolResultsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatRequestToolResultsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatRequestToolResultsItem(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatRequestToolResultsItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatSearchQueriesGenerationEvent struct {
	// Generated search queries, meant to be used as part of the RAG flow.
	SearchQueries []*ChatSearchQuery `json:"search_queries,omitempty" url:"search_queries,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatSearchQueriesGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchQueriesGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchQueriesGenerationEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchQueriesGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The generated search query. Contains the text of the query and a unique identifier for the query.
type ChatSearchQuery struct {
	// The text of the search query.
	Text string `json:"text" url:"text"`
	// Unique identifier for the generated search query. Useful for submitting feedback.
	GenerationId string `json:"generation_id" url:"generation_id"`

	_rawJSON json.RawMessage
}

func (c *ChatSearchQuery) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchQuery
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchQuery(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchQuery) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatSearchResult struct {
	SearchQuery *ChatSearchQuery `json:"search_query,omitempty" url:"search_query,omitempty"`
	// The connector from which this result comes from.
	Connector *ChatSearchResultConnector `json:"connector,omitempty" url:"connector,omitempty"`
	// Identifiers of documents found by this search query.
	DocumentIds []string `json:"document_ids,omitempty" url:"document_ids,omitempty"`
	// An error message if the search failed.
	ErrorMessage *string `json:"error_message,omitempty" url:"error_message,omitempty"`
	// Whether a chat request should continue or not if the request to this connector fails.
	ContinueOnFailure *bool `json:"continue_on_failure,omitempty" url:"continue_on_failure,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatSearchResult) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchResult
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchResult(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchResult) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The connector used for fetching documents.
type ChatSearchResultConnector struct {
	// The identifier of the connector.
	Id string `json:"id" url:"id"`

	_rawJSON json.RawMessage
}

func (c *ChatSearchResultConnector) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchResultConnector
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchResultConnector(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchResultConnector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatSearchResultsEvent struct {
	// Conducted searches and the ids of documents retrieved from each of them.
	SearchResults []*ChatSearchResult `json:"search_results,omitempty" url:"search_results,omitempty"`
	// Documents fetched from searches or provided by the user.
	Documents []ChatDocument `json:"documents,omitempty" url:"documents,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatSearchResultsEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatSearchResultsEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatSearchResultsEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatSearchResultsEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatStreamEndEvent struct {
	// - `COMPLETE` - the model sent back a finished reply
	// - `ERROR_LIMIT` - the reply was cut off because the model reached the maximum number of tokens for its context length
	// - `MAX_TOKENS` - the reply was cut off because the model reached the maximum number of tokens specified by the max_tokens parameter
	// - `ERROR` - something went wrong when generating the reply
	// - `ERROR_TOXIC` - the model generated a reply that was deemed toxic
	FinishReason ChatStreamEndEventFinishReason `json:"finish_reason" url:"finish_reason"`
	// The consolidated response from the model. Contains the generated reply and all the other information streamed back in the previous events.
	Response *NonStreamedChatResponse `json:"response,omitempty" url:"response,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatStreamEndEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamEndEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamEndEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamEndEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// - `COMPLETE` - the model sent back a finished reply
// - `ERROR_LIMIT` - the reply was cut off because the model reached the maximum number of tokens for its context length
// - `MAX_TOKENS` - the reply was cut off because the model reached the maximum number of tokens specified by the max_tokens parameter
// - `ERROR` - something went wrong when generating the reply
// - `ERROR_TOXIC` - the model generated a reply that was deemed toxic
type ChatStreamEndEventFinishReason string

const (
	ChatStreamEndEventFinishReasonComplete   ChatStreamEndEventFinishReason = "COMPLETE"
	ChatStreamEndEventFinishReasonErrorLimit ChatStreamEndEventFinishReason = "ERROR_LIMIT"
	ChatStreamEndEventFinishReasonMaxTokens  ChatStreamEndEventFinishReason = "MAX_TOKENS"
	ChatStreamEndEventFinishReasonError      ChatStreamEndEventFinishReason = "ERROR"
	ChatStreamEndEventFinishReasonErrorToxic ChatStreamEndEventFinishReason = "ERROR_TOXIC"
)

func NewChatStreamEndEventFinishReasonFromString(s string) (ChatStreamEndEventFinishReason, error) {
	switch s {
	case "COMPLETE":
		return ChatStreamEndEventFinishReasonComplete, nil
	case "ERROR_LIMIT":
		return ChatStreamEndEventFinishReasonErrorLimit, nil
	case "MAX_TOKENS":
		return ChatStreamEndEventFinishReasonMaxTokens, nil
	case "ERROR":
		return ChatStreamEndEventFinishReasonError, nil
	case "ERROR_TOXIC":
		return ChatStreamEndEventFinishReasonErrorToxic, nil
	}
	var t ChatStreamEndEventFinishReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatStreamEndEventFinishReason) Ptr() *ChatStreamEndEventFinishReason {
	return &c
}

type ChatStreamEvent struct {
	_rawJSON json.RawMessage
}

func (c *ChatStreamEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `"accurate"`.
//
// Dictates the approach taken to generating citations as part of the RAG flow by allowing the user to specify whether they want `"accurate"` results or `"fast"` results.
type ChatStreamRequestCitationQuality string

const (
	ChatStreamRequestCitationQualityFast     ChatStreamRequestCitationQuality = "fast"
	ChatStreamRequestCitationQualityAccurate ChatStreamRequestCitationQuality = "accurate"
)

func NewChatStreamRequestCitationQualityFromString(s string) (ChatStreamRequestCitationQuality, error) {
	switch s {
	case "fast":
		return ChatStreamRequestCitationQualityFast, nil
	case "accurate":
		return ChatStreamRequestCitationQualityAccurate, nil
	}
	var t ChatStreamRequestCitationQuality
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatStreamRequestCitationQuality) Ptr() *ChatStreamRequestCitationQuality {
	return &c
}

// (internal) Sets inference and model options for RAG search query and tool use generations. Defaults are used when options are not specified here, meaning that other parameters outside of connectors_search_options are ignored (such as model= or temperature=).
type ChatStreamRequestConnectorsSearchOptions struct {
	Model       interface{} `json:"model,omitempty" url:"model,omitempty"`
	Temperature interface{} `json:"temperature,omitempty" url:"temperature,omitempty"`
	MaxTokens   interface{} `json:"max_tokens,omitempty" url:"max_tokens,omitempty"`
	Preamble    interface{} `json:"preamble,omitempty" url:"preamble,omitempty"`
	// If specified, the backend will make a best effort to sample tokens deterministically, such that repeated requests with the same seed and parameters should return the same result. However, determinsim cannot be totally guaranteed.
	Seed *float64 `json:"seed,omitempty" url:"seed,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatStreamRequestConnectorsSearchOptions) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamRequestConnectorsSearchOptions
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamRequestConnectorsSearchOptions(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamRequestConnectorsSearchOptions) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Defaults to `AUTO` when `connectors` are specified and `OFF` in all other cases.
//
// Dictates how the prompt will be constructed.
//
// With `prompt_truncation` set to "AUTO", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be changed and ranked by relevance.
//
// With `prompt_truncation` set to "AUTO_PRESERVE_ORDER", some elements from `chat_history` and `documents` will be dropped in an attempt to construct a prompt that fits within the model's context length limit. During this process the order of the documents and chat history will be preserved as they are inputted into the API.
//
// With `prompt_truncation` set to "OFF", no elements will be dropped. If the sum of the inputs exceeds the model's context length limit, a `TooManyTokens` error will be returned.
type ChatStreamRequestPromptTruncation string

const (
	ChatStreamRequestPromptTruncationOff               ChatStreamRequestPromptTruncation = "OFF"
	ChatStreamRequestPromptTruncationAuto              ChatStreamRequestPromptTruncation = "AUTO"
	ChatStreamRequestPromptTruncationAutoPreserveOrder ChatStreamRequestPromptTruncation = "AUTO_PRESERVE_ORDER"
)

func NewChatStreamRequestPromptTruncationFromString(s string) (ChatStreamRequestPromptTruncation, error) {
	switch s {
	case "OFF":
		return ChatStreamRequestPromptTruncationOff, nil
	case "AUTO":
		return ChatStreamRequestPromptTruncationAuto, nil
	case "AUTO_PRESERVE_ORDER":
		return ChatStreamRequestPromptTruncationAutoPreserveOrder, nil
	}
	var t ChatStreamRequestPromptTruncation
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ChatStreamRequestPromptTruncation) Ptr() *ChatStreamRequestPromptTruncation {
	return &c
}

type ChatStreamRequestToolResultsItem struct {
	Call    *ToolCall                `json:"call,omitempty" url:"call,omitempty"`
	Outputs []map[string]interface{} `json:"outputs,omitempty" url:"outputs,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatStreamRequestToolResultsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamRequestToolResultsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamRequestToolResultsItem(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamRequestToolResultsItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatStreamStartEvent struct {
	// Unique identifier for the generated reply. Useful for submitting feedback.
	GenerationId string `json:"generation_id" url:"generation_id"`

	_rawJSON json.RawMessage
}

func (c *ChatStreamStartEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatStreamStartEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatStreamStartEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatStreamStartEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatTextGenerationEvent struct {
	// The next batch of text generated by the model.
	Text string `json:"text" url:"text"`

	_rawJSON json.RawMessage
}

func (c *ChatTextGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatTextGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatTextGenerationEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatTextGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ChatToolCallsGenerationEvent struct {
	ToolCalls []*ToolCall `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ChatToolCallsGenerationEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler ChatToolCallsGenerationEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ChatToolCallsGenerationEvent(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ChatToolCallsGenerationEvent) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClassifyDataMetrics struct {
	LabelMetrics []*LabelMetric `json:"label_metrics,omitempty" url:"label_metrics,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClassifyDataMetrics) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyDataMetrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyDataMetrics(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyDataMetrics) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClassifyExample struct {
	Text  *string `json:"text,omitempty" url:"text,omitempty"`
	Label *string `json:"label,omitempty" url:"label,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClassifyExample) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyExample
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyExample(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyExample) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type ClassifyRequestTruncate string

const (
	ClassifyRequestTruncateNone  ClassifyRequestTruncate = "NONE"
	ClassifyRequestTruncateStart ClassifyRequestTruncate = "START"
	ClassifyRequestTruncateEnd   ClassifyRequestTruncate = "END"
)

func NewClassifyRequestTruncateFromString(s string) (ClassifyRequestTruncate, error) {
	switch s {
	case "NONE":
		return ClassifyRequestTruncateNone, nil
	case "START":
		return ClassifyRequestTruncateStart, nil
	case "END":
		return ClassifyRequestTruncateEnd, nil
	}
	var t ClassifyRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClassifyRequestTruncate) Ptr() *ClassifyRequestTruncate {
	return &c
}

type ClassifyResponse struct {
	Id              string                                 `json:"id" url:"id"`
	Classifications []*ClassifyResponseClassificationsItem `json:"classifications,omitempty" url:"classifications,omitempty"`
	Meta            *ApiMeta                               `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClassifyResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type ClassifyResponseClassificationsItem struct {
	Id string `json:"id" url:"id"`
	// The input text that was classified
	Input *string `json:"input,omitempty" url:"input,omitempty"`
	// The predicted label for the associated query (only filled for single-label models)
	Prediction *string `json:"prediction,omitempty" url:"prediction,omitempty"`
	// An array containing the predicted labels for the associated query (only filled for single-label classification)
	Predictions []string `json:"predictions,omitempty" url:"predictions,omitempty"`
	// The confidence score for the top predicted class (only filled for single-label classification)
	Confidence *float64 `json:"confidence,omitempty" url:"confidence,omitempty"`
	// An array containing the confidence scores of all the predictions in the same order
	Confidences []float64 `json:"confidences,omitempty" url:"confidences,omitempty"`
	// A map containing each label and its confidence score according to the classifier. All the confidence scores add up to 1 for single-label classification. For multi-label classification the label confidences are independent of each other, so they don't have to sum up to 1.
	Labels map[string]*ClassifyResponseClassificationsItemLabelsValue `json:"labels,omitempty" url:"labels,omitempty"`
	// The type of classification performed
	ClassificationType ClassifyResponseClassificationsItemClassificationType `json:"classification_type" url:"classification_type"`

	_rawJSON json.RawMessage
}

func (c *ClassifyResponseClassificationsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyResponseClassificationsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyResponseClassificationsItem(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyResponseClassificationsItem) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The type of classification performed
type ClassifyResponseClassificationsItemClassificationType string

const (
	ClassifyResponseClassificationsItemClassificationTypeSingleLabel ClassifyResponseClassificationsItemClassificationType = "single-label"
	ClassifyResponseClassificationsItemClassificationTypeMultiLabel  ClassifyResponseClassificationsItemClassificationType = "multi-label"
)

func NewClassifyResponseClassificationsItemClassificationTypeFromString(s string) (ClassifyResponseClassificationsItemClassificationType, error) {
	switch s {
	case "single-label":
		return ClassifyResponseClassificationsItemClassificationTypeSingleLabel, nil
	case "multi-label":
		return ClassifyResponseClassificationsItemClassificationTypeMultiLabel, nil
	}
	var t ClassifyResponseClassificationsItemClassificationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ClassifyResponseClassificationsItemClassificationType) Ptr() *ClassifyResponseClassificationsItemClassificationType {
	return &c
}

type ClassifyResponseClassificationsItemLabelsValue struct {
	Confidence *float64 `json:"confidence,omitempty" url:"confidence,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ClassifyResponseClassificationsItemLabelsValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ClassifyResponseClassificationsItemLabelsValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ClassifyResponseClassificationsItemLabelsValue(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ClassifyResponseClassificationsItemLabelsValue) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// One of the Cohere API endpoints that the model can be used with.
type CompatibleEndpoint string

const (
	CompatibleEndpointChat      CompatibleEndpoint = "chat"
	CompatibleEndpointEmbed     CompatibleEndpoint = "embed"
	CompatibleEndpointClassify  CompatibleEndpoint = "classify"
	CompatibleEndpointSummarize CompatibleEndpoint = "summarize"
	CompatibleEndpointRerank    CompatibleEndpoint = "rerank"
	CompatibleEndpointRate      CompatibleEndpoint = "rate"
	CompatibleEndpointGenerate  CompatibleEndpoint = "generate"
)

func NewCompatibleEndpointFromString(s string) (CompatibleEndpoint, error) {
	switch s {
	case "chat":
		return CompatibleEndpointChat, nil
	case "embed":
		return CompatibleEndpointEmbed, nil
	case "classify":
		return CompatibleEndpointClassify, nil
	case "summarize":
		return CompatibleEndpointSummarize, nil
	case "rerank":
		return CompatibleEndpointRerank, nil
	case "rate":
		return CompatibleEndpointRate, nil
	case "generate":
		return CompatibleEndpointGenerate, nil
	}
	var t CompatibleEndpoint
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c CompatibleEndpoint) Ptr() *CompatibleEndpoint {
	return &c
}

// A connector allows you to integrate data sources with the '/chat' endpoint to create grounded generations with citations to the data source.
// documents to help answer users.
type Connector struct {
	// The unique identifier of the connector (used in both `/connectors` & `/chat` endpoints).
	// This is automatically created from the name of the connector upon registration.
	Id string `json:"id" url:"id"`
	// The organization to which this connector belongs. This is automatically set to
	// the organization of the user who created the connector.
	OrganizationId *string `json:"organization_id,omitempty" url:"organization_id,omitempty"`
	// A human-readable name for the connector.
	Name string `json:"name" url:"name"`
	// A description of the connector.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The URL of the connector that will be used to search for documents.
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The UTC time at which the connector was created.
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The UTC time at which the connector was last updated.
	UpdatedAt time.Time `json:"updated_at" url:"updated_at"`
	// A list of fields to exclude from the prompt (fields remain in the document).
	Excludes []string `json:"excludes,omitempty" url:"excludes,omitempty"`
	// The type of authentication/authorization used by the connector. Possible values: [oauth, service_auth]
	AuthType *string `json:"auth_type,omitempty" url:"auth_type,omitempty"`
	// The OAuth 2.0 configuration for the connector.
	Oauth *ConnectorOAuth `json:"oauth,omitempty" url:"oauth,omitempty"`
	// The OAuth status for the user making the request. One of ["valid", "expired", ""]. Empty string (field is omitted) means the user has not authorized the connector yet.
	AuthStatus *ConnectorAuthStatus `json:"auth_status,omitempty" url:"auth_status,omitempty"`
	// Whether the connector is active or not.
	Active *bool `json:"active,omitempty" url:"active,omitempty"`
	// Whether a chat request should continue or not if the request to this connector fails.
	ContinueOnFailure *bool `json:"continue_on_failure,omitempty" url:"continue_on_failure,omitempty"`

	_rawJSON json.RawMessage
}

func (c *Connector) UnmarshalJSON(data []byte) error {
	type embed Connector
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*c),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*c = Connector(unmarshaler.embed)
	c.CreatedAt = unmarshaler.CreatedAt.Time()
	c.UpdatedAt = unmarshaler.UpdatedAt.Time()

	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *Connector) MarshalJSON() ([]byte, error) {
	type embed Connector
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*c),
		CreatedAt: core.NewDateTime(c.CreatedAt),
		UpdatedAt: core.NewDateTime(c.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (c *Connector) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// The OAuth status for the user making the request. One of ["valid", "expired", ""]. Empty string (field is omitted) means the user has not authorized the connector yet.
type ConnectorAuthStatus string

const (
	ConnectorAuthStatusValid   ConnectorAuthStatus = "valid"
	ConnectorAuthStatusExpired ConnectorAuthStatus = "expired"
)

func NewConnectorAuthStatusFromString(s string) (ConnectorAuthStatus, error) {
	switch s {
	case "valid":
		return ConnectorAuthStatusValid, nil
	case "expired":
		return ConnectorAuthStatusExpired, nil
	}
	var t ConnectorAuthStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectorAuthStatus) Ptr() *ConnectorAuthStatus {
	return &c
}

type ConnectorOAuth struct {
	// The OAuth 2.0 client ID. This field is encrypted at rest.
	ClientId *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// The OAuth 2.0 client Secret. This field is encrypted at rest and never returned in a response.
	ClientSecret *string `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	// The OAuth 2.0 /authorize endpoint to use when users authorize the connector.
	AuthorizeUrl string `json:"authorize_url" url:"authorize_url"`
	// The OAuth 2.0 /token endpoint to use when users authorize the connector.
	TokenUrl string `json:"token_url" url:"token_url"`
	// The OAuth scopes to request when users authorize the connector.
	Scope *string `json:"scope,omitempty" url:"scope,omitempty"`

	_rawJSON json.RawMessage
}

func (c *ConnectorOAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler ConnectorOAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = ConnectorOAuth(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *ConnectorOAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectorOAuth struct {
	// The OAuth 2.0 client ID. This fields is encrypted at rest.
	ClientId *string `json:"client_id,omitempty" url:"client_id,omitempty"`
	// The OAuth 2.0 client Secret. This field is encrypted at rest and never returned in a response.
	ClientSecret *string `json:"client_secret,omitempty" url:"client_secret,omitempty"`
	// The OAuth 2.0 /authorize endpoint to use when users authorize the connector.
	AuthorizeUrl *string `json:"authorize_url,omitempty" url:"authorize_url,omitempty"`
	// The OAuth 2.0 /token endpoint to use when users authorize the connector.
	TokenUrl *string `json:"token_url,omitempty" url:"token_url,omitempty"`
	// The OAuth scopes to request when users authorize the connector.
	Scope *string `json:"scope,omitempty" url:"scope,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectorOAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorOAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorOAuth(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorOAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectorResponse struct {
	Connector *Connector `json:"connector,omitempty" url:"connector,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type CreateConnectorServiceAuth struct {
	Type AuthTokenType `json:"type" url:"type"`
	// The token that will be used in the HTTP Authorization header when making requests to the connector. This field is encrypted at rest and never returned in a response.
	Token string `json:"token" url:"token"`

	_rawJSON json.RawMessage
}

func (c *CreateConnectorServiceAuth) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateConnectorServiceAuth
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateConnectorServiceAuth(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateConnectorServiceAuth) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

// Response from creating an embed job.
type CreateEmbedJobResponse struct {
	JobId string   `json:"job_id" url:"job_id"`
	Meta  *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (c *CreateEmbedJobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler CreateEmbedJobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*c = CreateEmbedJobResponse(value)
	c._rawJSON = json.RawMessage(data)
	return nil
}

func (c *CreateEmbedJobResponse) String() string {
	if len(c._rawJSON) > 0 {
		if value, err := core.StringifyJSON(c._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(c); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", c)
}

type Dataset struct {
	// The dataset ID
	Id string `json:"id" url:"id"`
	// The name of the dataset
	Name string `json:"name" url:"name"`
	// The creation date
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// The last update date
	UpdatedAt        time.Time               `json:"updated_at" url:"updated_at"`
	DatasetType      DatasetType             `json:"dataset_type" url:"dataset_type"`
	ValidationStatus DatasetValidationStatus `json:"validation_status" url:"validation_status"`
	// Errors found during validation
	ValidationError *string `json:"validation_error,omitempty" url:"validation_error,omitempty"`
	// the avro schema of the dataset
	Schema         *string  `json:"schema,omitempty" url:"schema,omitempty"`
	RequiredFields []string `json:"required_fields,omitempty" url:"required_fields,omitempty"`
	PreserveFields []string `json:"preserve_fields,omitempty" url:"preserve_fields,omitempty"`
	// the underlying files that make up the dataset
	DatasetParts []*DatasetPart `json:"dataset_parts,omitempty" url:"dataset_parts,omitempty"`
	// warnings found during validation
	ValidationWarnings []string `json:"validation_warnings,omitempty" url:"validation_warnings,omitempty"`

	_rawJSON json.RawMessage
}

func (d *Dataset) UnmarshalJSON(data []byte) error {
	type embed Dataset
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed: embed(*d),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*d = Dataset(unmarshaler.embed)
	d.CreatedAt = unmarshaler.CreatedAt.Time()
	d.UpdatedAt = unmarshaler.UpdatedAt.Time()

	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *Dataset) MarshalJSON() ([]byte, error) {
	type embed Dataset
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
		UpdatedAt *core.DateTime `json:"updated_at"`
	}{
		embed:     embed(*d),
		CreatedAt: core.NewDateTime(d.CreatedAt),
		UpdatedAt: core.NewDateTime(d.UpdatedAt),
	}
	return json.Marshal(marshaler)
}

func (d *Dataset) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type DatasetPart struct {
	// The dataset part ID
	Id string `json:"id" url:"id"`
	// The name of the dataset part
	Name string `json:"name" url:"name"`
	// The download url of the file
	Url *string `json:"url,omitempty" url:"url,omitempty"`
	// The index of the file
	Index *int `json:"index,omitempty" url:"index,omitempty"`
	// The size of the file in bytes
	SizeBytes *int `json:"size_bytes,omitempty" url:"size_bytes,omitempty"`
	// The number of rows in the file
	NumRows *int `json:"num_rows,omitempty" url:"num_rows,omitempty"`
	// The download url of the original file
	OriginalUrl *string `json:"original_url,omitempty" url:"original_url,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DatasetPart) UnmarshalJSON(data []byte) error {
	type unmarshaler DatasetPart
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DatasetPart(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DatasetPart) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

// The type of the dataset
type DatasetType string

const (
	DatasetTypeEmbedInput                             DatasetType = "embed-input"
	DatasetTypeEmbedResult                            DatasetType = "embed-result"
	DatasetTypeClusterResult                          DatasetType = "cluster-result"
	DatasetTypeClusterOutliers                        DatasetType = "cluster-outliers"
	DatasetTypeRerankerFinetuneInput                  DatasetType = "reranker-finetune-input"
	DatasetTypePromptCompletionFinetuneInput          DatasetType = "prompt-completion-finetune-input"
	DatasetTypeSingleLabelClassificationFinetuneInput DatasetType = "single-label-classification-finetune-input"
	DatasetTypeChatFinetuneInput                      DatasetType = "chat-finetune-input"
	DatasetTypeMultiLabelClassificationFinetuneInput  DatasetType = "multi-label-classification-finetune-input"
)

func NewDatasetTypeFromString(s string) (DatasetType, error) {
	switch s {
	case "embed-input":
		return DatasetTypeEmbedInput, nil
	case "embed-result":
		return DatasetTypeEmbedResult, nil
	case "cluster-result":
		return DatasetTypeClusterResult, nil
	case "cluster-outliers":
		return DatasetTypeClusterOutliers, nil
	case "reranker-finetune-input":
		return DatasetTypeRerankerFinetuneInput, nil
	case "prompt-completion-finetune-input":
		return DatasetTypePromptCompletionFinetuneInput, nil
	case "single-label-classification-finetune-input":
		return DatasetTypeSingleLabelClassificationFinetuneInput, nil
	case "chat-finetune-input":
		return DatasetTypeChatFinetuneInput, nil
	case "multi-label-classification-finetune-input":
		return DatasetTypeMultiLabelClassificationFinetuneInput, nil
	}
	var t DatasetType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DatasetType) Ptr() *DatasetType {
	return &d
}

// The validation status of the dataset
type DatasetValidationStatus string

const (
	DatasetValidationStatusUnknown    DatasetValidationStatus = "unknown"
	DatasetValidationStatusQueued     DatasetValidationStatus = "queued"
	DatasetValidationStatusProcessing DatasetValidationStatus = "processing"
	DatasetValidationStatusFailed     DatasetValidationStatus = "failed"
	DatasetValidationStatusValidated  DatasetValidationStatus = "validated"
	DatasetValidationStatusSkipped    DatasetValidationStatus = "skipped"
)

func NewDatasetValidationStatusFromString(s string) (DatasetValidationStatus, error) {
	switch s {
	case "unknown":
		return DatasetValidationStatusUnknown, nil
	case "queued":
		return DatasetValidationStatusQueued, nil
	case "processing":
		return DatasetValidationStatusProcessing, nil
	case "failed":
		return DatasetValidationStatusFailed, nil
	case "validated":
		return DatasetValidationStatusValidated, nil
	case "skipped":
		return DatasetValidationStatusSkipped, nil
	}
	var t DatasetValidationStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DatasetValidationStatus) Ptr() *DatasetValidationStatus {
	return &d
}

type DeleteConnectorResponse = map[string]interface{}

type DetokenizeResponse struct {
	// A string representing the list of tokens.
	Text string   `json:"text" url:"text"`
	Meta *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DetokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler DetokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DetokenizeResponse(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DetokenizeResponse) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}

type EmbedByTypeResponse struct {
	Id string `json:"id" url:"id"`
	// An object with different embedding types. The length of each embedding type array will be the same as the length of the original `texts` array.
	Embeddings *EmbedByTypeResponseEmbeddings `json:"embeddings,omitempty" url:"embeddings,omitempty"`
	// The text entries for which embeddings were returned.
	Texts []string `json:"texts,omitempty" url:"texts,omitempty"`
	Meta  *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmbedByTypeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedByTypeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedByTypeResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedByTypeResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// An object with different embedding types. The length of each embedding type array will be the same as the length of the original `texts` array.
type EmbedByTypeResponseEmbeddings struct {
	// An array of float embeddings.
	Float [][]float64 `json:"float,omitempty" url:"float,omitempty"`
	// An array of signed int8 embeddings. Each value is between -128 and 127.
	Int8 [][]int `json:"int8,omitempty" url:"int8,omitempty"`
	// An array of unsigned int8 embeddings. Each value is between 0 and 255.
	Uint8 [][]int `json:"uint8,omitempty" url:"uint8,omitempty"`
	// An array of packed signed binary embeddings. The length of each binary embedding is 1/8 the length of the float embeddings of the provided model. Each value is between -128 and 127.
	Binary [][]int `json:"binary,omitempty" url:"binary,omitempty"`
	// An array of packed unsigned binary embeddings. The length of each binary embedding is 1/8 the length of the float embeddings of the provided model. Each value is between 0 and 255.
	Ubinary [][]int `json:"ubinary,omitempty" url:"ubinary,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmbedByTypeResponseEmbeddings) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedByTypeResponseEmbeddings
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedByTypeResponseEmbeddings(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedByTypeResponseEmbeddings) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type EmbedFloatsResponse struct {
	Id string `json:"id" url:"id"`
	// An array of embeddings, where each embedding is an array of floats. The length of the `embeddings` array will be the same as the length of the original `texts` array.
	Embeddings [][]float64 `json:"embeddings,omitempty" url:"embeddings,omitempty"`
	// The text entries for which embeddings were returned.
	Texts []string `json:"texts,omitempty" url:"texts,omitempty"`
	Meta  *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmbedFloatsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler EmbedFloatsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EmbedFloatsResponse(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedFloatsResponse) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Specifies the type of input passed to the model. Required for embedding models v3 and higher.
//
// - `"search_document"`: Used for embeddings stored in a vector database for search use-cases.
// - `"search_query"`: Used for embeddings of search queries run against a vector DB to find relevant documents.
// - `"classification"`: Used for embeddings passed through a text classifier.
// - `"clustering"`: Used for the embeddings run through a clustering algorithm.
type EmbedInputType string

const (
	EmbedInputTypeSearchDocument EmbedInputType = "search_document"
	EmbedInputTypeSearchQuery    EmbedInputType = "search_query"
	EmbedInputTypeClassification EmbedInputType = "classification"
	EmbedInputTypeClustering     EmbedInputType = "clustering"
)

func NewEmbedInputTypeFromString(s string) (EmbedInputType, error) {
	switch s {
	case "search_document":
		return EmbedInputTypeSearchDocument, nil
	case "search_query":
		return EmbedInputTypeSearchQuery, nil
	case "classification":
		return EmbedInputTypeClassification, nil
	case "clustering":
		return EmbedInputTypeClustering, nil
	}
	var t EmbedInputType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedInputType) Ptr() *EmbedInputType {
	return &e
}

type EmbedJob struct {
	// ID of the embed job
	JobId string `json:"job_id" url:"job_id"`
	// The name of the embed job
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The status of the embed job
	Status EmbedJobStatus `json:"status" url:"status"`
	// The creation date of the embed job
	CreatedAt time.Time `json:"created_at" url:"created_at"`
	// ID of the input dataset
	InputDatasetId string `json:"input_dataset_id" url:"input_dataset_id"`
	// ID of the resulting output dataset
	OutputDatasetId *string `json:"output_dataset_id,omitempty" url:"output_dataset_id,omitempty"`
	// ID of the model used to embed
	Model string `json:"model" url:"model"`
	// The truncation option used
	Truncate EmbedJobTruncate `json:"truncate" url:"truncate"`
	Meta     *ApiMeta         `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (e *EmbedJob) UnmarshalJSON(data []byte) error {
	type embed EmbedJob
	var unmarshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed: embed(*e),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*e = EmbedJob(unmarshaler.embed)
	e.CreatedAt = unmarshaler.CreatedAt.Time()

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EmbedJob) MarshalJSON() ([]byte, error) {
	type embed EmbedJob
	var marshaler = struct {
		embed
		CreatedAt *core.DateTime `json:"created_at"`
	}{
		embed:     embed(*e),
		CreatedAt: core.NewDateTime(e.CreatedAt),
	}
	return json.Marshal(marshaler)
}

func (e *EmbedJob) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// The status of the embed job
type EmbedJobStatus string

const (
	EmbedJobStatusProcessing EmbedJobStatus = "processing"
	EmbedJobStatusComplete   EmbedJobStatus = "complete"
	EmbedJobStatusCancelling EmbedJobStatus = "cancelling"
	EmbedJobStatusCancelled  EmbedJobStatus = "cancelled"
	EmbedJobStatusFailed     EmbedJobStatus = "failed"
)

func NewEmbedJobStatusFromString(s string) (EmbedJobStatus, error) {
	switch s {
	case "processing":
		return EmbedJobStatusProcessing, nil
	case "complete":
		return EmbedJobStatusComplete, nil
	case "cancelling":
		return EmbedJobStatusCancelling, nil
	case "cancelled":
		return EmbedJobStatusCancelled, nil
	case "failed":
		return EmbedJobStatusFailed, nil
	}
	var t EmbedJobStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedJobStatus) Ptr() *EmbedJobStatus {
	return &e
}

// The truncation option used
type EmbedJobTruncate string

const (
	EmbedJobTruncateStart EmbedJobTruncate = "START"
	EmbedJobTruncateEnd   EmbedJobTruncate = "END"
)

func NewEmbedJobTruncateFromString(s string) (EmbedJobTruncate, error) {
	switch s {
	case "START":
		return EmbedJobTruncateStart, nil
	case "END":
		return EmbedJobTruncateEnd, nil
	}
	var t EmbedJobTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedJobTruncate) Ptr() *EmbedJobTruncate {
	return &e
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type EmbedRequestTruncate string

const (
	EmbedRequestTruncateNone  EmbedRequestTruncate = "NONE"
	EmbedRequestTruncateStart EmbedRequestTruncate = "START"
	EmbedRequestTruncateEnd   EmbedRequestTruncate = "END"
)

func NewEmbedRequestTruncateFromString(s string) (EmbedRequestTruncate, error) {
	switch s {
	case "NONE":
		return EmbedRequestTruncateNone, nil
	case "START":
		return EmbedRequestTruncateStart, nil
	case "END":
		return EmbedRequestTruncateEnd, nil
	}
	var t EmbedRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbedRequestTruncate) Ptr() *EmbedRequestTruncate {
	return &e
}

type EmbedResponse struct {
	ResponseType     string
	EmbeddingsFloats *EmbedFloatsResponse
	EmbeddingsByType *EmbedByTypeResponse
}

func (e *EmbedResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		ResponseType string `json:"response_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	e.ResponseType = unmarshaler.ResponseType
	switch unmarshaler.ResponseType {
	case "embeddings_floats":
		value := new(EmbedFloatsResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EmbeddingsFloats = value
	case "embeddings_by_type":
		value := new(EmbedByTypeResponse)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		e.EmbeddingsByType = value
	}
	return nil
}

func (e EmbedResponse) MarshalJSON() ([]byte, error) {
	if e.EmbeddingsFloats != nil {
		var marshaler = struct {
			ResponseType string `json:"response_type"`
			*EmbedFloatsResponse
		}{
			ResponseType:        "embeddings_floats",
			EmbedFloatsResponse: e.EmbeddingsFloats,
		}
		return json.Marshal(marshaler)
	}
	if e.EmbeddingsByType != nil {
		var marshaler = struct {
			ResponseType string `json:"response_type"`
			*EmbedByTypeResponse
		}{
			ResponseType:        "embeddings_by_type",
			EmbedByTypeResponse: e.EmbeddingsByType,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EmbedResponseVisitor interface {
	VisitEmbeddingsFloats(*EmbedFloatsResponse) error
	VisitEmbeddingsByType(*EmbedByTypeResponse) error
}

func (e *EmbedResponse) Accept(visitor EmbedResponseVisitor) error {
	if e.EmbeddingsFloats != nil {
		return visitor.VisitEmbeddingsFloats(e.EmbeddingsFloats)
	}
	if e.EmbeddingsByType != nil {
		return visitor.VisitEmbeddingsByType(e.EmbeddingsByType)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", e)
}

type EmbeddingType string

const (
	EmbeddingTypeFloat   EmbeddingType = "float"
	EmbeddingTypeInt8    EmbeddingType = "int8"
	EmbeddingTypeUint8   EmbeddingType = "uint8"
	EmbeddingTypeBinary  EmbeddingType = "binary"
	EmbeddingTypeUbinary EmbeddingType = "ubinary"
)

func NewEmbeddingTypeFromString(s string) (EmbeddingType, error) {
	switch s {
	case "float":
		return EmbeddingTypeFloat, nil
	case "int8":
		return EmbeddingTypeInt8, nil
	case "uint8":
		return EmbeddingTypeUint8, nil
	case "binary":
		return EmbeddingTypeBinary, nil
	case "ubinary":
		return EmbeddingTypeUbinary, nil
	}
	var t EmbeddingType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EmbeddingType) Ptr() *EmbeddingType {
	return &e
}

type FinetuneDatasetMetrics struct {
	// The number of tokens of valid examples that can be used for training.
	TrainableTokenCount *string `json:"trainable_token_count,omitempty" url:"trainable_token_count,omitempty"`
	// The overall number of examples.
	TotalExamples *string `json:"total_examples,omitempty" url:"total_examples,omitempty"`
	// The number of training examples.
	TrainExamples *string `json:"train_examples,omitempty" url:"train_examples,omitempty"`
	// The size in bytes of all training examples.
	TrainSizeBytes *string `json:"train_size_bytes,omitempty" url:"train_size_bytes,omitempty"`
	// Number of evaluation examples.
	EvalExamples *string `json:"eval_examples,omitempty" url:"eval_examples,omitempty"`
	// The size in bytes of all eval examples.
	EvalSizeBytes *string `json:"eval_size_bytes,omitempty" url:"eval_size_bytes,omitempty"`

	_rawJSON json.RawMessage
}

func (f *FinetuneDatasetMetrics) UnmarshalJSON(data []byte) error {
	type unmarshaler FinetuneDatasetMetrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FinetuneDatasetMetrics(value)
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FinetuneDatasetMetrics) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type FinishReason string

const (
	FinishReasonComplete   FinishReason = "COMPLETE"
	FinishReasonError      FinishReason = "ERROR"
	FinishReasonErrorToxic FinishReason = "ERROR_TOXIC"
	FinishReasonErrorLimit FinishReason = "ERROR_LIMIT"
	FinishReasonUserCancel FinishReason = "USER_CANCEL"
	FinishReasonMaxTokens  FinishReason = "MAX_TOKENS"
)

func NewFinishReasonFromString(s string) (FinishReason, error) {
	switch s {
	case "COMPLETE":
		return FinishReasonComplete, nil
	case "ERROR":
		return FinishReasonError, nil
	case "ERROR_TOXIC":
		return FinishReasonErrorToxic, nil
	case "ERROR_LIMIT":
		return FinishReasonErrorLimit, nil
	case "USER_CANCEL":
		return FinishReasonUserCancel, nil
	case "MAX_TOKENS":
		return FinishReasonMaxTokens, nil
	}
	var t FinishReason
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FinishReason) Ptr() *FinishReason {
	return &f
}

// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
//
// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
//
// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
type GenerateRequestReturnLikelihoods string

const (
	GenerateRequestReturnLikelihoodsGeneration GenerateRequestReturnLikelihoods = "GENERATION"
	GenerateRequestReturnLikelihoodsAll        GenerateRequestReturnLikelihoods = "ALL"
	GenerateRequestReturnLikelihoodsNone       GenerateRequestReturnLikelihoods = "NONE"
)

func NewGenerateRequestReturnLikelihoodsFromString(s string) (GenerateRequestReturnLikelihoods, error) {
	switch s {
	case "GENERATION":
		return GenerateRequestReturnLikelihoodsGeneration, nil
	case "ALL":
		return GenerateRequestReturnLikelihoodsAll, nil
	case "NONE":
		return GenerateRequestReturnLikelihoodsNone, nil
	}
	var t GenerateRequestReturnLikelihoods
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateRequestReturnLikelihoods) Ptr() *GenerateRequestReturnLikelihoods {
	return &g
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type GenerateRequestTruncate string

const (
	GenerateRequestTruncateNone  GenerateRequestTruncate = "NONE"
	GenerateRequestTruncateStart GenerateRequestTruncate = "START"
	GenerateRequestTruncateEnd   GenerateRequestTruncate = "END"
)

func NewGenerateRequestTruncateFromString(s string) (GenerateRequestTruncate, error) {
	switch s {
	case "NONE":
		return GenerateRequestTruncateNone, nil
	case "START":
		return GenerateRequestTruncateStart, nil
	case "END":
		return GenerateRequestTruncateEnd, nil
	}
	var t GenerateRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateRequestTruncate) Ptr() *GenerateRequestTruncate {
	return &g
}

type GenerateStreamEnd struct {
	IsFinished   bool                       `json:"is_finished" url:"is_finished"`
	FinishReason *FinishReason              `json:"finish_reason,omitempty" url:"finish_reason,omitempty"`
	Response     *GenerateStreamEndResponse `json:"response,omitempty" url:"response,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GenerateStreamEnd) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamEnd
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamEnd(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamEnd) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateStreamEndResponse struct {
	Id          string                      `json:"id" url:"id"`
	Prompt      *string                     `json:"prompt,omitempty" url:"prompt,omitempty"`
	Generations []*SingleGenerationInStream `json:"generations,omitempty" url:"generations,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GenerateStreamEndResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamEndResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamEndResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamEndResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateStreamError struct {
	// Refers to the nth generation. Only present when `num_generations` is greater than zero.
	Index        *int         `json:"index,omitempty" url:"index,omitempty"`
	IsFinished   bool         `json:"is_finished" url:"is_finished"`
	FinishReason FinishReason `json:"finish_reason" url:"finish_reason"`
	// Error message
	Err string `json:"err" url:"err"`

	_rawJSON json.RawMessage
}

func (g *GenerateStreamError) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamError(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamError) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GenerateStreamEvent struct {
	_rawJSON json.RawMessage
}

func (g *GenerateStreamEvent) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamEvent
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamEvent(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamEvent) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// One of `GENERATION|ALL|NONE` to specify how and if the token likelihoods are returned with the response. Defaults to `NONE`.
//
// If `GENERATION` is selected, the token likelihoods will only be provided for generated text.
//
// If `ALL` is selected, the token likelihoods will be provided both for the prompt and the generated text.
type GenerateStreamRequestReturnLikelihoods string

const (
	GenerateStreamRequestReturnLikelihoodsGeneration GenerateStreamRequestReturnLikelihoods = "GENERATION"
	GenerateStreamRequestReturnLikelihoodsAll        GenerateStreamRequestReturnLikelihoods = "ALL"
	GenerateStreamRequestReturnLikelihoodsNone       GenerateStreamRequestReturnLikelihoods = "NONE"
)

func NewGenerateStreamRequestReturnLikelihoodsFromString(s string) (GenerateStreamRequestReturnLikelihoods, error) {
	switch s {
	case "GENERATION":
		return GenerateStreamRequestReturnLikelihoodsGeneration, nil
	case "ALL":
		return GenerateStreamRequestReturnLikelihoodsAll, nil
	case "NONE":
		return GenerateStreamRequestReturnLikelihoodsNone, nil
	}
	var t GenerateStreamRequestReturnLikelihoods
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateStreamRequestReturnLikelihoods) Ptr() *GenerateStreamRequestReturnLikelihoods {
	return &g
}

// One of `NONE|START|END` to specify how the API will handle inputs longer than the maximum token length.
//
// Passing `START` will discard the start of the input. `END` will discard the end of the input. In both cases, input is discarded until the remaining input is exactly the maximum input token length for the model.
//
// If `NONE` is selected, when the input exceeds the maximum input token length an error will be returned.
type GenerateStreamRequestTruncate string

const (
	GenerateStreamRequestTruncateNone  GenerateStreamRequestTruncate = "NONE"
	GenerateStreamRequestTruncateStart GenerateStreamRequestTruncate = "START"
	GenerateStreamRequestTruncateEnd   GenerateStreamRequestTruncate = "END"
)

func NewGenerateStreamRequestTruncateFromString(s string) (GenerateStreamRequestTruncate, error) {
	switch s {
	case "NONE":
		return GenerateStreamRequestTruncateNone, nil
	case "START":
		return GenerateStreamRequestTruncateStart, nil
	case "END":
		return GenerateStreamRequestTruncateEnd, nil
	}
	var t GenerateStreamRequestTruncate
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (g GenerateStreamRequestTruncate) Ptr() *GenerateStreamRequestTruncate {
	return &g
}

type GenerateStreamText struct {
	// A segment of text of the generation.
	Text string `json:"text" url:"text"`
	// Refers to the nth generation. Only present when `num_generations` is greater than zero, and only when text responses are being streamed.
	Index      *int `json:"index,omitempty" url:"index,omitempty"`
	IsFinished bool `json:"is_finished" url:"is_finished"`

	_rawJSON json.RawMessage
}

func (g *GenerateStreamText) UnmarshalJSON(data []byte) error {
	type unmarshaler GenerateStreamText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GenerateStreamText(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GenerateStreamText) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Response in content type stream when `stream` is `true` in the request parameters. Generation tokens are streamed with the GenerationStream response. The final response is of type GenerationFinalResponse.
type GenerateStreamedResponse struct {
	EventType      string
	TextGeneration *GenerateStreamText
	StreamEnd      *GenerateStreamEnd
	StreamError    *GenerateStreamError
}

func (g *GenerateStreamedResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"event_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	g.EventType = unmarshaler.EventType
	switch unmarshaler.EventType {
	case "text-generation":
		value := new(GenerateStreamText)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.TextGeneration = value
	case "stream-end":
		value := new(GenerateStreamEnd)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.StreamEnd = value
	case "stream-error":
		value := new(GenerateStreamError)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		g.StreamError = value
	}
	return nil
}

func (g GenerateStreamedResponse) MarshalJSON() ([]byte, error) {
	if g.TextGeneration != nil {
		var marshaler = struct {
			EventType string `json:"event_type"`
			*GenerateStreamText
		}{
			EventType:          "text-generation",
			GenerateStreamText: g.TextGeneration,
		}
		return json.Marshal(marshaler)
	}
	if g.StreamEnd != nil {
		var marshaler = struct {
			EventType string `json:"event_type"`
			*GenerateStreamEnd
		}{
			EventType:         "stream-end",
			GenerateStreamEnd: g.StreamEnd,
		}
		return json.Marshal(marshaler)
	}
	if g.StreamError != nil {
		var marshaler = struct {
			EventType string `json:"event_type"`
			*GenerateStreamError
		}{
			EventType:           "stream-error",
			GenerateStreamError: g.StreamError,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", g)
}

type GenerateStreamedResponseVisitor interface {
	VisitTextGeneration(*GenerateStreamText) error
	VisitStreamEnd(*GenerateStreamEnd) error
	VisitStreamError(*GenerateStreamError) error
}

func (g *GenerateStreamedResponse) Accept(visitor GenerateStreamedResponseVisitor) error {
	if g.TextGeneration != nil {
		return visitor.VisitTextGeneration(g.TextGeneration)
	}
	if g.StreamEnd != nil {
		return visitor.VisitStreamEnd(g.StreamEnd)
	}
	if g.StreamError != nil {
		return visitor.VisitStreamError(g.StreamError)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", g)
}

type Generation struct {
	Id string `json:"id" url:"id"`
	// Prompt used for generations.
	Prompt *string `json:"prompt,omitempty" url:"prompt,omitempty"`
	// List of generated results
	Generations []*SingleGeneration `json:"generations,omitempty" url:"generations,omitempty"`
	Meta        *ApiMeta            `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (g *Generation) UnmarshalJSON(data []byte) error {
	type unmarshaler Generation
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Generation(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Generation) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GetConnectorResponse struct {
	Connector *Connector `json:"connector,omitempty" url:"connector,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetConnectorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetConnectorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetConnectorResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetConnectorResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Contains information about the model and which API endpoints it can be used with.
type GetModelResponse struct {
	// Specify this name in the `model` parameter of API requests to use your chosen model.
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The API endpoints that the model is compatible with.
	Endpoints []CompatibleEndpoint `json:"endpoints,omitempty" url:"endpoints,omitempty"`
	// Whether the model has been fine-tuned or not.
	Finetuned *bool `json:"finetuned,omitempty" url:"finetuned,omitempty"`
	// The maximum number of tokens that the model can process in a single request. Note that not all of these tokens are always available due to special tokens and preambles that Cohere has added by default.
	ContextLength *float64 `json:"context_length,omitempty" url:"context_length,omitempty"`
	// Public URL to the tokenizer's configuration file.
	TokenizerUrl *string `json:"tokenizer_url,omitempty" url:"tokenizer_url,omitempty"`
	// The API endpoints that the model is default to.
	DefaultEndpoints []CompatibleEndpoint `json:"default_endpoints,omitempty" url:"default_endpoints,omitempty"`

	_rawJSON json.RawMessage
}

func (g *GetModelResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetModelResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetModelResponse(value)
	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetModelResponse) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type LabelMetric struct {
	// Total number of examples for this label
	TotalExamples *string `json:"total_examples,omitempty" url:"total_examples,omitempty"`
	// value of the label
	Label *string `json:"label,omitempty" url:"label,omitempty"`
	// samples for this label
	Samples []string `json:"samples,omitempty" url:"samples,omitempty"`

	_rawJSON json.RawMessage
}

func (l *LabelMetric) UnmarshalJSON(data []byte) error {
	type unmarshaler LabelMetric
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = LabelMetric(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *LabelMetric) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListConnectorsResponse struct {
	Connectors []*Connector `json:"connectors,omitempty" url:"connectors,omitempty"`
	// Total number of connectors.
	TotalCount *float64 `json:"total_count,omitempty" url:"total_count,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListConnectorsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListConnectorsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListConnectorsResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListConnectorsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListEmbedJobResponse struct {
	EmbedJobs []*EmbedJob `json:"embed_jobs,omitempty" url:"embed_jobs,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListEmbedJobResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListEmbedJobResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListEmbedJobResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListEmbedJobResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type ListModelsResponse struct {
	Models []*GetModelResponse `json:"models,omitempty" url:"models,omitempty"`
	// A token to retrieve the next page of results. Provide in the page_token parameter of the next request.
	NextPageToken *string `json:"next_page_token,omitempty" url:"next_page_token,omitempty"`

	_rawJSON json.RawMessage
}

func (l *ListModelsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListModelsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListModelsResponse(value)
	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListModelsResponse) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

type Metrics struct {
	FinetuneDatasetMetrics *FinetuneDatasetMetrics `json:"finetune_dataset_metrics,omitempty" url:"finetune_dataset_metrics,omitempty"`

	_rawJSON json.RawMessage
}

func (m *Metrics) UnmarshalJSON(data []byte) error {
	type unmarshaler Metrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*m = Metrics(value)
	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metrics) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type NonStreamedChatResponse struct {
	// Contents of the reply generated by the model.
	Text string `json:"text" url:"text"`
	// Unique identifier for the generated reply. Useful for submitting feedback.
	GenerationId *string `json:"generation_id,omitempty" url:"generation_id,omitempty"`
	// Inline citations for the generated reply.
	Citations []*ChatCitation `json:"citations,omitempty" url:"citations,omitempty"`
	// Documents seen by the model when generating the reply.
	Documents []ChatDocument `json:"documents,omitempty" url:"documents,omitempty"`
	// Denotes that a search for documents is required during the RAG flow.
	IsSearchRequired *bool `json:"is_search_required,omitempty" url:"is_search_required,omitempty"`
	// Generated search queries, meant to be used as part of the RAG flow.
	SearchQueries []*ChatSearchQuery `json:"search_queries,omitempty" url:"search_queries,omitempty"`
	// Documents retrieved from each of the conducted searches.
	SearchResults []*ChatSearchResult `json:"search_results,omitempty" url:"search_results,omitempty"`
	FinishReason  *FinishReason       `json:"finish_reason,omitempty" url:"finish_reason,omitempty"`
	ToolCalls     []*ToolCall         `json:"tool_calls,omitempty" url:"tool_calls,omitempty"`
	// A list of previous messages between the user and the model, meant to give the model conversational context for responding to the user's `message`.
	ChatHistory []*ChatMessage `json:"chat_history,omitempty" url:"chat_history,omitempty"`
	// The prompt that was used. Only present when `return_prompt` in the request is set to true.
	Prompt *string  `json:"prompt,omitempty" url:"prompt,omitempty"`
	Meta   *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (n *NonStreamedChatResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler NonStreamedChatResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*n = NonStreamedChatResponse(value)
	n._rawJSON = json.RawMessage(data)
	return nil
}

func (n *NonStreamedChatResponse) String() string {
	if len(n._rawJSON) > 0 {
		if value, err := core.StringifyJSON(n._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(n); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", n)
}

type OAuthAuthorizeResponse struct {
	// The OAuth 2.0 redirect url. Redirect the user to this url to authorize the connector.
	RedirectUrl *string `json:"redirect_url,omitempty" url:"redirect_url,omitempty"`

	_rawJSON json.RawMessage
}

func (o *OAuthAuthorizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler OAuthAuthorizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*o = OAuthAuthorizeResponse(value)
	o._rawJSON = json.RawMessage(data)
	return nil
}

func (o *OAuthAuthorizeResponse) String() string {
	if len(o._rawJSON) > 0 {
		if value, err := core.StringifyJSON(o._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(o); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", o)
}

type ParseInfo struct {
	Separator *string `json:"separator,omitempty" url:"separator,omitempty"`
	Delimiter *string `json:"delimiter,omitempty" url:"delimiter,omitempty"`

	_rawJSON json.RawMessage
}

func (p *ParseInfo) UnmarshalJSON(data []byte) error {
	type unmarshaler ParseInfo
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = ParseInfo(value)
	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *ParseInfo) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

type RerankRequestDocumentsItem struct {
	String                         string
	RerankRequestDocumentsItemText *RerankRequestDocumentsItemText
}

func (r *RerankRequestDocumentsItem) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.String = valueString
		return nil
	}
	valueRerankRequestDocumentsItemText := new(RerankRequestDocumentsItemText)
	if err := json.Unmarshal(data, &valueRerankRequestDocumentsItemText); err == nil {
		r.RerankRequestDocumentsItemText = valueRerankRequestDocumentsItemText
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RerankRequestDocumentsItem) MarshalJSON() ([]byte, error) {
	if r.String != "" {
		return json.Marshal(r.String)
	}
	if r.RerankRequestDocumentsItemText != nil {
		return json.Marshal(r.RerankRequestDocumentsItemText)
	}
	return nil, fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RerankRequestDocumentsItemVisitor interface {
	VisitString(string) error
	VisitRerankRequestDocumentsItemText(*RerankRequestDocumentsItemText) error
}

func (r *RerankRequestDocumentsItem) Accept(visitor RerankRequestDocumentsItemVisitor) error {
	if r.String != "" {
		return visitor.VisitString(r.String)
	}
	if r.RerankRequestDocumentsItemText != nil {
		return visitor.VisitRerankRequestDocumentsItemText(r.RerankRequestDocumentsItemText)
	}
	return fmt.Errorf("type %T does not include a non-empty union type", r)
}

type RerankRequestDocumentsItemText struct {
	// The text of the document to rerank.
	Text string `json:"text" url:"text"`

	_rawJSON json.RawMessage
}

func (r *RerankRequestDocumentsItemText) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankRequestDocumentsItemText
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankRequestDocumentsItemText(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankRequestDocumentsItemText) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RerankResponse struct {
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// An ordered list of ranked documents
	Results []*RerankResponseResultsItem `json:"results,omitempty" url:"results,omitempty"`
	Meta    *ApiMeta                     `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RerankResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankResponse(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankResponse) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RerankResponseResultsItem struct {
	// If `return_documents` is set as `false` this will return none, if `true` it will return the documents passed in
	Document *RerankResponseResultsItemDocument `json:"document,omitempty" url:"document,omitempty"`
	// Corresponds to the index in the original list of documents to which the ranked document belongs. (i.e. if the first value in the `results` object has an `index` value of 3, it means in the list of documents passed in, the document at `index=3` had the highest relevance)
	Index int `json:"index" url:"index"`
	// Relevance scores are normalized to be in the range `[0, 1]`. Scores close to `1` indicate a high relevance to the query, and scores closer to `0` indicate low relevance. It is not accurate to assume a score of 0.9 means the document is 2x more relevant than a document with a score of 0.45
	RelevanceScore float64 `json:"relevance_score" url:"relevance_score"`

	_rawJSON json.RawMessage
}

func (r *RerankResponseResultsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankResponseResultsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankResponseResultsItem(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankResponseResultsItem) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// If `return_documents` is set as `false` this will return none, if `true` it will return the documents passed in
type RerankResponseResultsItemDocument struct {
	// The text of the document to rerank
	Text string `json:"text" url:"text"`

	_rawJSON json.RawMessage
}

func (r *RerankResponseResultsItemDocument) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankResponseResultsItemDocument
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankResponseResultsItemDocument(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankResponseResultsItemDocument) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RerankerDataMetrics struct {
	// The number of training queries.
	NumTrainQueries *string `json:"num_train_queries,omitempty" url:"num_train_queries,omitempty"`
	// The sum of all relevant passages of valid training examples.
	NumTrainRelevantPassages *string `json:"num_train_relevant_passages,omitempty" url:"num_train_relevant_passages,omitempty"`
	// The sum of all hard negatives of valid training examples.
	NumTrainHardNegatives *string `json:"num_train_hard_negatives,omitempty" url:"num_train_hard_negatives,omitempty"`
	// The number of evaluation queries.
	NumEvalQueries *string `json:"num_eval_queries,omitempty" url:"num_eval_queries,omitempty"`
	// The sum of all relevant passages of valid eval examples.
	NumEvalRelevantPassages *string `json:"num_eval_relevant_passages,omitempty" url:"num_eval_relevant_passages,omitempty"`
	// The sum of all hard negatives of valid eval examples.
	NumEvalHardNegatives *string `json:"num_eval_hard_negatives,omitempty" url:"num_eval_hard_negatives,omitempty"`

	_rawJSON json.RawMessage
}

func (r *RerankerDataMetrics) UnmarshalJSON(data []byte) error {
	type unmarshaler RerankerDataMetrics
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RerankerDataMetrics(value)
	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RerankerDataMetrics) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type SingleGeneration struct {
	Id   string `json:"id" url:"id"`
	Text string `json:"text" url:"text"`
	// Refers to the nth generation. Only present when `num_generations` is greater than zero.
	Index      *int     `json:"index,omitempty" url:"index,omitempty"`
	Likelihood *float64 `json:"likelihood,omitempty" url:"likelihood,omitempty"`
	// Only returned if `return_likelihoods` is set to `GENERATION` or `ALL`. The likelihood refers to the average log-likelihood of the entire specified string, which is useful for [evaluating the performance of your model](likelihood-eval), especially if you've created a [custom model](/docs/training-custom-models). Individual token likelihoods provide the log-likelihood of each token. The first token will not have a likelihood.
	TokenLikelihoods []*SingleGenerationTokenLikelihoodsItem `json:"token_likelihoods,omitempty" url:"token_likelihoods,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SingleGeneration) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleGeneration
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleGeneration(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleGeneration) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleGenerationInStream struct {
	Id string `json:"id" url:"id"`
	// Full text of the generation.
	Text string `json:"text" url:"text"`
	// Refers to the nth generation. Only present when `num_generations` is greater than zero.
	Index        *int         `json:"index,omitempty" url:"index,omitempty"`
	FinishReason FinishReason `json:"finish_reason" url:"finish_reason"`

	_rawJSON json.RawMessage
}

func (s *SingleGenerationInStream) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleGenerationInStream
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleGenerationInStream(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleGenerationInStream) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type SingleGenerationTokenLikelihoodsItem struct {
	Token      string  `json:"token" url:"token"`
	Likelihood float64 `json:"likelihood" url:"likelihood"`

	_rawJSON json.RawMessage
}

func (s *SingleGenerationTokenLikelihoodsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler SingleGenerationTokenLikelihoodsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SingleGenerationTokenLikelihoodsItem(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SingleGenerationTokenLikelihoodsItem) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

// StreamedChatResponse is returned in streaming mode (specified with `stream=True` in the request).
type StreamedChatResponse struct {
	EventType               string
	StreamStart             *ChatStreamStartEvent
	SearchQueriesGeneration *ChatSearchQueriesGenerationEvent
	SearchResults           *ChatSearchResultsEvent
	TextGeneration          *ChatTextGenerationEvent
	CitationGeneration      *ChatCitationGenerationEvent
	ToolCallsGeneration     *ChatToolCallsGenerationEvent
	StreamEnd               *ChatStreamEndEvent
}

func (s *StreamedChatResponse) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		EventType string `json:"event_type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	s.EventType = unmarshaler.EventType
	switch unmarshaler.EventType {
	case "stream-start":
		value := new(ChatStreamStartEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.StreamStart = value
	case "search-queries-generation":
		value := new(ChatSearchQueriesGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SearchQueriesGeneration = value
	case "search-results":
		value := new(ChatSearchResultsEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.SearchResults = value
	case "text-generation":
		value := new(ChatTextGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.TextGeneration = value
	case "citation-generation":
		value := new(ChatCitationGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.CitationGeneration = value
	case "tool-calls-generation":
		value := new(ChatToolCallsGenerationEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.ToolCallsGeneration = value
	case "stream-end":
		value := new(ChatStreamEndEvent)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		s.StreamEnd = value
	}
	return nil
}

func (s StreamedChatResponse) MarshalJSON() ([]byte, error) {
	if s.StreamStart != nil {
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatStreamStartEvent
		}{
			EventType:            "stream-start",
			ChatStreamStartEvent: s.StreamStart,
		}
		return json.Marshal(marshaler)
	}
	if s.SearchQueriesGeneration != nil {
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatSearchQueriesGenerationEvent
		}{
			EventType:                        "search-queries-generation",
			ChatSearchQueriesGenerationEvent: s.SearchQueriesGeneration,
		}
		return json.Marshal(marshaler)
	}
	if s.SearchResults != nil {
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatSearchResultsEvent
		}{
			EventType:              "search-results",
			ChatSearchResultsEvent: s.SearchResults,
		}
		return json.Marshal(marshaler)
	}
	if s.TextGeneration != nil {
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatTextGenerationEvent
		}{
			EventType:               "text-generation",
			ChatTextGenerationEvent: s.TextGeneration,
		}
		return json.Marshal(marshaler)
	}
	if s.CitationGeneration != nil {
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatCitationGenerationEvent
		}{
			EventType:                   "citation-generation",
			ChatCitationGenerationEvent: s.CitationGeneration,
		}
		return json.Marshal(marshaler)
	}
	if s.ToolCallsGeneration != nil {
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatToolCallsGenerationEvent
		}{
			EventType:                    "tool-calls-generation",
			ChatToolCallsGenerationEvent: s.ToolCallsGeneration,
		}
		return json.Marshal(marshaler)
	}
	if s.StreamEnd != nil {
		var marshaler = struct {
			EventType string `json:"event_type"`
			*ChatStreamEndEvent
		}{
			EventType:          "stream-end",
			ChatStreamEndEvent: s.StreamEnd,
		}
		return json.Marshal(marshaler)
	}
	return nil, fmt.Errorf("type %T does not define a non-empty union type", s)
}

type StreamedChatResponseVisitor interface {
	VisitStreamStart(*ChatStreamStartEvent) error
	VisitSearchQueriesGeneration(*ChatSearchQueriesGenerationEvent) error
	VisitSearchResults(*ChatSearchResultsEvent) error
	VisitTextGeneration(*ChatTextGenerationEvent) error
	VisitCitationGeneration(*ChatCitationGenerationEvent) error
	VisitToolCallsGeneration(*ChatToolCallsGenerationEvent) error
	VisitStreamEnd(*ChatStreamEndEvent) error
}

func (s *StreamedChatResponse) Accept(visitor StreamedChatResponseVisitor) error {
	if s.StreamStart != nil {
		return visitor.VisitStreamStart(s.StreamStart)
	}
	if s.SearchQueriesGeneration != nil {
		return visitor.VisitSearchQueriesGeneration(s.SearchQueriesGeneration)
	}
	if s.SearchResults != nil {
		return visitor.VisitSearchResults(s.SearchResults)
	}
	if s.TextGeneration != nil {
		return visitor.VisitTextGeneration(s.TextGeneration)
	}
	if s.CitationGeneration != nil {
		return visitor.VisitCitationGeneration(s.CitationGeneration)
	}
	if s.ToolCallsGeneration != nil {
		return visitor.VisitToolCallsGeneration(s.ToolCallsGeneration)
	}
	if s.StreamEnd != nil {
		return visitor.VisitStreamEnd(s.StreamEnd)
	}
	return fmt.Errorf("type %T does not define a non-empty union type", s)
}

// One of `low`, `medium`, `high`, or `auto`, defaults to `auto`. Controls how close to the original text the summary is. `high` extractiveness summaries will lean towards reusing sentences verbatim, while `low` extractiveness summaries will tend to paraphrase more. If `auto` is selected, the best option will be picked based on the input text.
type SummarizeRequestExtractiveness string

const (
	SummarizeRequestExtractivenessLow    SummarizeRequestExtractiveness = "low"
	SummarizeRequestExtractivenessMedium SummarizeRequestExtractiveness = "medium"
	SummarizeRequestExtractivenessHigh   SummarizeRequestExtractiveness = "high"
)

func NewSummarizeRequestExtractivenessFromString(s string) (SummarizeRequestExtractiveness, error) {
	switch s {
	case "low":
		return SummarizeRequestExtractivenessLow, nil
	case "medium":
		return SummarizeRequestExtractivenessMedium, nil
	case "high":
		return SummarizeRequestExtractivenessHigh, nil
	}
	var t SummarizeRequestExtractiveness
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SummarizeRequestExtractiveness) Ptr() *SummarizeRequestExtractiveness {
	return &s
}

// One of `paragraph`, `bullets`, or `auto`, defaults to `auto`. Indicates the style in which the summary will be delivered - in a free form paragraph or in bullet points. If `auto` is selected, the best option will be picked based on the input text.
type SummarizeRequestFormat string

const (
	SummarizeRequestFormatParagraph SummarizeRequestFormat = "paragraph"
	SummarizeRequestFormatBullets   SummarizeRequestFormat = "bullets"
)

func NewSummarizeRequestFormatFromString(s string) (SummarizeRequestFormat, error) {
	switch s {
	case "paragraph":
		return SummarizeRequestFormatParagraph, nil
	case "bullets":
		return SummarizeRequestFormatBullets, nil
	}
	var t SummarizeRequestFormat
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SummarizeRequestFormat) Ptr() *SummarizeRequestFormat {
	return &s
}

// One of `short`, `medium`, `long`, or `auto` defaults to `auto`. Indicates the approximate length of the summary. If `auto` is selected, the best option will be picked based on the input text.
type SummarizeRequestLength string

const (
	SummarizeRequestLengthShort  SummarizeRequestLength = "short"
	SummarizeRequestLengthMedium SummarizeRequestLength = "medium"
	SummarizeRequestLengthLong   SummarizeRequestLength = "long"
)

func NewSummarizeRequestLengthFromString(s string) (SummarizeRequestLength, error) {
	switch s {
	case "short":
		return SummarizeRequestLengthShort, nil
	case "medium":
		return SummarizeRequestLengthMedium, nil
	case "long":
		return SummarizeRequestLengthLong, nil
	}
	var t SummarizeRequestLength
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SummarizeRequestLength) Ptr() *SummarizeRequestLength {
	return &s
}

type SummarizeResponse struct {
	// Generated ID for the summary
	Id *string `json:"id,omitempty" url:"id,omitempty"`
	// Generated summary for the text
	Summary *string  `json:"summary,omitempty" url:"summary,omitempty"`
	Meta    *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (s *SummarizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler SummarizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*s = SummarizeResponse(value)
	s._rawJSON = json.RawMessage(data)
	return nil
}

func (s *SummarizeResponse) String() string {
	if len(s._rawJSON) > 0 {
		if value, err := core.StringifyJSON(s._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}

type TokenizeResponse struct {
	// An array of tokens, where each token is an integer.
	Tokens       []int    `json:"tokens,omitempty" url:"tokens,omitempty"`
	TokenStrings []string `json:"token_strings,omitempty" url:"token_strings,omitempty"`
	Meta         *ApiMeta `json:"meta,omitempty" url:"meta,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TokenizeResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler TokenizeResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TokenizeResponse(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TokenizeResponse) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type TooManyRequestsErrorBody struct {
	Data *string `json:"data,omitempty" url:"data,omitempty"`

	_rawJSON json.RawMessage
}

func (t *TooManyRequestsErrorBody) UnmarshalJSON(data []byte) error {
	type unmarshaler TooManyRequestsErrorBody
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TooManyRequestsErrorBody(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *TooManyRequestsErrorBody) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type Tool struct {
	// The name of the tool to be called. Valid names contain only the characters `a-z`, `A-Z`, `0-9`, `_` and must not begin with a digit.
	Name string `json:"name" url:"name"`
	// The description of what the tool does, the model uses the description to choose when and how to call the function.
	Description string `json:"description" url:"description"`
	// The input parameters of the tool. Accepts a dictionary where the key is the name of the parameter and the value is the parameter spec. Valid parameter names contain only the characters `a-z`, `A-Z`, `0-9`, `_` and must not begin with a digit.
	//
	// ```
	//
	//	{
	//	  "my_param": {
	//	    "description": <string>,
	//	    "type": <string>, // any python data type, such as 'str', 'bool'
	//	    "required": <boolean>
	//	  }
	//	}
	//
	// ```
	ParameterDefinitions map[string]*ToolParameterDefinitionsValue `json:"parameter_definitions,omitempty" url:"parameter_definitions,omitempty"`

	_rawJSON json.RawMessage
}

func (t *Tool) UnmarshalJSON(data []byte) error {
	type unmarshaler Tool
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = Tool(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *Tool) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

// Contains the tool calls generated by the model. Use it to invoke your tools.
type ToolCall struct {
	// Name of the tool to call.
	Name string `json:"name" url:"name"`
	// The name and value of the parameters to use when invoking a tool.
	Parameters map[string]interface{} `json:"parameters,omitempty" url:"parameters,omitempty"`

	_rawJSON json.RawMessage
}

func (t *ToolCall) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolCall
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolCall(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolCall) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type ToolParameterDefinitionsValue struct {
	// The description of the parameter.
	Description *string `json:"description,omitempty" url:"description,omitempty"`
	// The type of the parameter. Must be a valid Python type.
	Type string `json:"type" url:"type"`
	// Denotes whether the parameter is always present (required) or not. Defaults to not required.
	Required *bool `json:"required,omitempty" url:"required,omitempty"`

	_rawJSON json.RawMessage
}

func (t *ToolParameterDefinitionsValue) UnmarshalJSON(data []byte) error {
	type unmarshaler ToolParameterDefinitionsValue
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = ToolParameterDefinitionsValue(value)
	t._rawJSON = json.RawMessage(data)
	return nil
}

func (t *ToolParameterDefinitionsValue) String() string {
	if len(t._rawJSON) > 0 {
		if value, err := core.StringifyJSON(t._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(t); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", t)
}

type UpdateConnectorResponse struct {
	Connector *Connector `json:"connector,omitempty" url:"connector,omitempty"`

	_rawJSON json.RawMessage
}

func (u *UpdateConnectorResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler UpdateConnectorResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*u = UpdateConnectorResponse(value)
	u._rawJSON = json.RawMessage(data)
	return nil
}

func (u *UpdateConnectorResponse) String() string {
	if len(u._rawJSON) > 0 {
		if value, err := core.StringifyJSON(u._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(u); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", u)
}

// the underlying files that make up the dataset
type DatasetsCreateResponseDatasetParts struct {
	// the name of the dataset part
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// the number of rows in the dataset part
	NumRows *float64 `json:"num_rows,omitempty" url:"num_rows,omitempty"`
	Samples []string `json:"samples,omitempty" url:"samples,omitempty"`
	// the kind of dataset part
	PartKind *string `json:"part_kind,omitempty" url:"part_kind,omitempty"`

	_rawJSON json.RawMessage
}

func (d *DatasetsCreateResponseDatasetParts) UnmarshalJSON(data []byte) error {
	type unmarshaler DatasetsCreateResponseDatasetParts
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DatasetsCreateResponseDatasetParts(value)
	d._rawJSON = json.RawMessage(data)
	return nil
}

func (d *DatasetsCreateResponseDatasetParts) String() string {
	if len(d._rawJSON) > 0 {
		if value, err := core.StringifyJSON(d._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(d); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", d)
}
